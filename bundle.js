(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/bean/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./bean.js\"}\n//@ sourceURL=/node_modules/bean/package.json"
));

require.define("/node_modules/bean/bean.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n  * bean.js - copyright Jacob Thornton 2011\n  * https://github.com/fat/bean\n  * MIT License\n  * special thanks to:\n  * dean edwards: http://dean.edwards.name/\n  * dperini: https://github.com/dperini/nwevents\n  * the entire mootools team: github.com/mootools/mootools-core\n  */\n!function (name, context, definition) {\n  if (typeof module !== 'undefined') module.exports = definition(name, context);\n  else if (typeof define === 'function' && typeof define.amd  === 'object') define(definition);\n  else context[name] = definition(name, context);\n}('bean', this, function (name, context) {\n  var win = window\n    , old = context[name]\n    , overOut = /over|out/\n    , namespaceRegex = /[^\\.]*(?=\\..*)\\.|.*/\n    , nameRegex = /\\..*/\n    , addEvent = 'addEventListener'\n    , attachEvent = 'attachEvent'\n    , removeEvent = 'removeEventListener'\n    , detachEvent = 'detachEvent'\n    , ownerDocument = 'ownerDocument'\n    , targetS = 'target'\n    , qSA = 'querySelectorAll'\n    , doc = document || {}\n    , root = doc.documentElement || {}\n    , W3C_MODEL = root[addEvent]\n    , eventSupport = W3C_MODEL ? addEvent : attachEvent\n    , slice = Array.prototype.slice\n    , mouseTypeRegex = /click|mouse(?!(.*wheel|scroll))|menu|drag|drop/i\n    , mouseWheelTypeRegex = /mouse.*(wheel|scroll)/i\n    , textTypeRegex = /^text/i\n    , touchTypeRegex = /^touch|^gesture/i\n    , ONE = {} // singleton for quick matching making add() do one()\n\n    , nativeEvents = (function (hash, events, i) {\n        for (i = 0; i < events.length; i++)\n          hash[events[i]] = 1\n        return hash\n      }({}, (\n          'click dblclick mouseup mousedown contextmenu ' +                  // mouse buttons\n          'mousewheel mousemultiwheel DOMMouseScroll ' +                     // mouse wheel\n          'mouseover mouseout mousemove selectstart selectend ' +            // mouse movement\n          'keydown keypress keyup ' +                                        // keyboard\n          'orientationchange ' +                                             // mobile\n          'focus blur change reset select submit ' +                         // form elements\n          'load unload beforeunload resize move DOMContentLoaded '+          // window\n          'readystatechange message ' +                                      // window\n          'error abort scroll ' +                                            // misc\n          (W3C_MODEL ? // element.fireEvent('onXYZ'... is not forgiving if we try to fire an event\n                       // that doesn't actually exist, so make sure we only do these on newer browsers\n            'show ' +                                                          // mouse buttons\n            'input invalid ' +                                                 // form elements\n            'touchstart touchmove touchend touchcancel ' +                     // touch\n            'gesturestart gesturechange gestureend ' +                         // gesture\n            'readystatechange pageshow pagehide popstate ' +                   // window\n            'hashchange offline online ' +                                     // window\n            'afterprint beforeprint ' +                                        // printing\n            'dragstart dragenter dragover dragleave drag drop dragend ' +      // dnd\n            'loadstart progress suspend emptied stalled loadmetadata ' +       // media\n            'loadeddata canplay canplaythrough playing waiting seeking ' +     // media\n            'seeked ended durationchange timeupdate play pause ratechange ' +  // media\n            'volumechange cuechange ' +                                        // media\n            'checking noupdate downloading cached updateready obsolete ' +     // appcache\n            '' : '')\n        ).split(' ')\n      ))\n\n    , customEvents = (function () {\n        var cdp = 'compareDocumentPosition'\n          , isAncestor = cdp in root\n              ? function (element, container) {\n                  return container[cdp] && (container[cdp](element) & 16) === 16\n                }\n              : 'contains' in root\n                ? function (element, container) {\n                    container = container.nodeType === 9 || container === window ? root : container\n                    return container !== element && container.contains(element)\n                  }\n                : function (element, container) {\n                    while (element = element.parentNode) if (element === container) return 1\n                    return 0\n                  }\n\n        function check(event) {\n          var related = event.relatedTarget\n          return !related\n            ? related === null\n            : (related !== this && related.prefix !== 'xul' && !/document/.test(this.toString()) && !isAncestor(related, this))\n        }\n\n        return {\n            mouseenter: { base: 'mouseover', condition: check }\n          , mouseleave: { base: 'mouseout', condition: check }\n          , mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }\n        }\n      }())\n\n    , fixEvent = (function () {\n        var commonProps = 'altKey attrChange attrName bubbles cancelable ctrlKey currentTarget detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey srcElement target timeStamp type view which'.split(' ')\n          , mouseProps = commonProps.concat('button buttons clientX clientY dataTransfer fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '))\n          , mouseWheelProps = mouseProps.concat('wheelDelta wheelDeltaX wheelDeltaY wheelDeltaZ axis'.split(' ')) // 'axis' is FF specific\n          , keyProps = commonProps.concat('char charCode key keyCode keyIdentifier keyLocation'.split(' '))\n          , textProps = commonProps.concat(['data'])\n          , touchProps = commonProps.concat('touches targetTouches changedTouches scale rotation'.split(' '))\n          , messageProps = commonProps.concat(['data', 'origin', 'source'])\n          , preventDefault = 'preventDefault'\n          , createPreventDefault = function (event) {\n              return function () {\n                if (event[preventDefault])\n                  event[preventDefault]()\n                else\n                  event.returnValue = false\n              }\n            }\n          , stopPropagation = 'stopPropagation'\n          , createStopPropagation = function (event) {\n              return function () {\n                if (event[stopPropagation])\n                  event[stopPropagation]()\n                else\n                  event.cancelBubble = true\n              }\n            }\n          , createStop = function (synEvent) {\n              return function () {\n                synEvent[preventDefault]()\n                synEvent[stopPropagation]()\n                synEvent.stopped = true\n              }\n            }\n          , copyProps = function (event, result, props) {\n              var i, p\n              for (i = props.length; i--;) {\n                p = props[i]\n                if (!(p in result) && p in event) result[p] = event[p]\n              }\n            }\n\n        return function (event, isNative) {\n          var result = { originalEvent: event, isNative: isNative }\n          if (!event)\n            return result\n\n          var props\n            , type = event.type\n            , target = event[targetS] || event.srcElement\n\n          result[preventDefault] = createPreventDefault(event)\n          result[stopPropagation] = createStopPropagation(event)\n          result.stop = createStop(result)\n          result[targetS] = target && target.nodeType === 3 ? target.parentNode : target\n\n          if (isNative) { // we only need basic augmentation on custom events, the rest is too expensive\n            if (type.indexOf('key') !== -1) {\n              props = keyProps\n              result.keyCode = event.keyCode || event.which\n            } else if (mouseTypeRegex.test(type)) {\n              props = mouseProps\n              result.rightClick = event.which === 3 || event.button === 2\n              result.pos = { x: 0, y: 0 }\n              if (event.pageX || event.pageY) {\n                result.clientX = event.pageX\n                result.clientY = event.pageY\n              } else if (event.clientX || event.clientY) {\n                result.clientX = event.clientX + doc.body.scrollLeft + root.scrollLeft\n                result.clientY = event.clientY + doc.body.scrollTop + root.scrollTop\n              }\n              if (overOut.test(type))\n                result.relatedTarget = event.relatedTarget || event[(type === 'mouseover' ? 'from' : 'to') + 'Element']\n            } else if (touchTypeRegex.test(type)) {\n              props = touchProps\n            } else if (mouseWheelTypeRegex.test(type)) {\n              props = mouseWheelProps\n            } else if (textTypeRegex.test(type)) {\n              props = textProps\n            } else if (type === 'message') {\n              props = messageProps\n            }\n            copyProps(event, result, props || commonProps)\n          }\n          return result\n        }\n      }())\n\n      // if we're in old IE we can't do onpropertychange on doc or win so we use doc.documentElement for both\n    , targetElement = function (element, isNative) {\n        return !W3C_MODEL && !isNative && (element === doc || element === win) ? root : element\n      }\n\n      // we use one of these per listener, of any type\n    , RegEntry = (function () {\n        function entry(element, type, handler, original, namespaces) {\n          var isNative = this.isNative = nativeEvents[type] && element[eventSupport]\n          this.element = element\n          this.type = type\n          this.handler = handler\n          this.original = original\n          this.namespaces = namespaces\n          this.custom = customEvents[type]\n          this.eventType = W3C_MODEL || isNative ? type : 'propertychange'\n          this.customType = !W3C_MODEL && !isNative && type\n          this[targetS] = targetElement(element, isNative)\n          this[eventSupport] = this[targetS][eventSupport]\n        }\n\n        entry.prototype = {\n            // given a list of namespaces, is our entry in any of them?\n            inNamespaces: function (checkNamespaces) {\n              var i, j\n              if (!checkNamespaces)\n                return true\n              if (!this.namespaces)\n                return false\n              for (i = checkNamespaces.length; i--;) {\n                for (j = this.namespaces.length; j--;) {\n                  if (checkNamespaces[i] === this.namespaces[j])\n                    return true\n                }\n              }\n              return false\n            }\n\n            // match by element, original fn (opt), handler fn (opt)\n          , matches: function (checkElement, checkOriginal, checkHandler) {\n              return this.element === checkElement &&\n                (!checkOriginal || this.original === checkOriginal) &&\n                (!checkHandler || this.handler === checkHandler)\n            }\n        }\n\n        return entry\n      }())\n\n    , registry = (function () {\n        // our map stores arrays by event type, just because it's better than storing\n        // everything in a single array. uses '$' as a prefix for the keys for safety\n        var map = {}\n\n          // generic functional search of our registry for matching listeners,\n          // `fn` returns false to break out of the loop\n          , forAll = function (element, type, original, handler, fn) {\n              if (!type || type === '*') {\n                // search the whole registry\n                for (var t in map) {\n                  if (t.charAt(0) === '$')\n                    forAll(element, t.substr(1), original, handler, fn)\n                }\n              } else {\n                var i = 0, l, list = map['$' + type], all = element === '*'\n                if (!list)\n                  return\n                for (l = list.length; i < l; i++) {\n                  if (all || list[i].matches(element, original, handler))\n                    if (!fn(list[i], list, i, type))\n                      return\n                }\n              }\n            }\n\n          , has = function (element, type, original) {\n              // we're not using forAll here simply because it's a bit slower and this\n              // needs to be fast\n              var i, list = map['$' + type]\n              if (list) {\n                for (i = list.length; i--;) {\n                  if (list[i].matches(element, original, null))\n                    return true\n                }\n              }\n              return false\n            }\n\n          , get = function (element, type, original) {\n              var entries = []\n              forAll(element, type, original, null, function (entry) { return entries.push(entry) })\n              return entries\n            }\n\n          , put = function (entry) {\n              (map['$' + entry.type] || (map['$' + entry.type] = [])).push(entry)\n              return entry\n            }\n\n          , del = function (entry) {\n              forAll(entry.element, entry.type, null, entry.handler, function (entry, list, i) {\n                list.splice(i, 1)\n                if (list.length === 0)\n                  delete map['$' + entry.type]\n                return false\n              })\n            }\n\n            // dump all entries, used for onunload\n          , entries = function () {\n              var t, entries = []\n              for (t in map) {\n                if (t.charAt(0) === '$')\n                  entries = entries.concat(map[t])\n              }\n              return entries\n            }\n\n        return { has: has, get: get, put: put, del: del, entries: entries }\n      }())\n\n    , selectorEngine = doc[qSA]\n        ? function (s, r) {\n            return r[qSA](s)\n          }\n        : function () {\n            throw new Error('Bean: No selector engine installed') // eeek\n          }\n\n    , setSelectorEngine = function (e) {\n        selectorEngine = e\n      }\n\n      // add and remove listeners to DOM elements\n    , listener = W3C_MODEL ? function (element, type, fn, add) {\n        element[add ? addEvent : removeEvent](type, fn, false)\n      } : function (element, type, fn, add, custom) {\n        if (custom && add && element['_on' + custom] === null)\n          element['_on' + custom] = 0\n        element[add ? attachEvent : detachEvent]('on' + type, fn)\n      }\n\n    , nativeHandler = function (element, fn, args) {\n        var beanDel = fn.__beanDel\n          , handler = function (event) {\n          event = fixEvent(event || ((this[ownerDocument] || this.document || this).parentWindow || win).event, true)\n          if (beanDel) // delegated event, fix the fix\n            event.currentTarget = beanDel.ft(event[targetS], element)\n          return fn.apply(element, [event].concat(args))\n        }\n        handler.__beanDel = beanDel\n        return handler\n      }\n\n    , customHandler = function (element, fn, type, condition, args, isNative) {\n        var beanDel = fn.__beanDel\n          , handler = function (event) {\n          var target = beanDel ? beanDel.ft(event[targetS], element) : this // deleated event\n          if (condition ? condition.apply(target, arguments) : W3C_MODEL ? true : event && event.propertyName === '_on' + type || !event) {\n            if (event) {\n              event = fixEvent(event || ((this[ownerDocument] || this.document || this).parentWindow || win).event, isNative)\n              event.currentTarget = target\n            }\n            fn.apply(element, event && (!args || args.length === 0) ? arguments : slice.call(arguments, event ? 0 : 1).concat(args))\n          }\n        }\n        handler.__beanDel = beanDel\n        return handler\n      }\n\n    , once = function (rm, element, type, fn, originalFn) {\n        // wrap the handler in a handler that does a remove as well\n        return function () {\n          rm(element, type, originalFn)\n          fn.apply(this, arguments)\n        }\n      }\n\n    , removeListener = function (element, orgType, handler, namespaces) {\n        var i, l, entry\n          , type = (orgType && orgType.replace(nameRegex, ''))\n          , handlers = registry.get(element, type, handler)\n\n        for (i = 0, l = handlers.length; i < l; i++) {\n          if (handlers[i].inNamespaces(namespaces)) {\n            if ((entry = handlers[i])[eventSupport])\n              listener(entry[targetS], entry.eventType, entry.handler, false, entry.type)\n            // TODO: this is problematic, we have a registry.get() and registry.del() that\n            // both do registry searches so we waste cycles doing this. Needs to be rolled into\n            // a single registry.forAll(fn) that removes while finding, but the catch is that\n            // we'll be splicing the arrays that we're iterating over. Needs extra tests to\n            // make sure we don't screw it up. @rvagg\n            registry.del(entry)\n          }\n        }\n      }\n\n    , addListener = function (element, orgType, fn, originalFn, args) {\n        var entry\n          , type = orgType.replace(nameRegex, '')\n          , namespaces = orgType.replace(namespaceRegex, '').split('.')\n\n        if (registry.has(element, type, fn))\n          return element // no dupe\n        if (type === 'unload')\n          fn = once(removeListener, element, type, fn, originalFn) // self clean-up\n        if (customEvents[type]) {\n          if (customEvents[type].condition)\n            fn = customHandler(element, fn, type, customEvents[type].condition, args, true)\n          type = customEvents[type].base || type\n        }\n        entry = registry.put(new RegEntry(element, type, fn, originalFn, namespaces[0] && namespaces))\n        entry.handler = entry.isNative ?\n          nativeHandler(element, entry.handler, args) :\n          customHandler(element, entry.handler, type, false, args, false)\n        if (entry[eventSupport])\n          listener(entry[targetS], entry.eventType, entry.handler, true, entry.customType)\n      }\n\n    , del = function (selector, fn, $) {\n            //TODO: findTarget (therefore $) is called twice, once for match and once for\n            // setting e.currentTarget, fix this so it's only needed once\n        var findTarget = function (target, root) {\n              var i, array = typeof selector === 'string' ? $(selector, root) : selector\n              for (; target && target !== root; target = target.parentNode) {\n                for (i = array.length; i--;) {\n                  if (array[i] === target)\n                    return target\n                }\n              }\n            }\n          , handler = function (e) {\n              var match = findTarget(e[targetS], this)\n              match && fn.apply(match, arguments)\n            }\n\n        handler.__beanDel = {\n            ft: findTarget // attach it here for customEvents to use too\n          , selector: selector\n          , $: $\n        }\n        return handler\n      }\n\n    , remove = function (element, typeSpec, fn) {\n        var k, type, namespaces, i\n          , rm = removeListener\n          , isString = typeSpec && typeof typeSpec === 'string'\n\n        if (isString && typeSpec.indexOf(' ') > 0) {\n          // remove(el, 't1 t2 t3', fn) or remove(el, 't1 t2 t3')\n          typeSpec = typeSpec.split(' ')\n          for (i = typeSpec.length; i--;)\n            remove(element, typeSpec[i], fn)\n          return element\n        }\n        type = isString && typeSpec.replace(nameRegex, '')\n        if (type && customEvents[type])\n          type = customEvents[type].type\n        if (!typeSpec || isString) {\n          // remove(el) or remove(el, t1.ns) or remove(el, .ns) or remove(el, .ns1.ns2.ns3)\n          if (namespaces = isString && typeSpec.replace(namespaceRegex, ''))\n            namespaces = namespaces.split('.')\n          rm(element, type, fn, namespaces)\n        } else if (typeof typeSpec === 'function') {\n          // remove(el, fn)\n          rm(element, null, typeSpec)\n        } else {\n          // remove(el, { t1: fn1, t2, fn2 })\n          for (k in typeSpec) {\n            if (typeSpec.hasOwnProperty(k))\n              remove(element, k, typeSpec[k])\n          }\n        }\n        return element\n      }\n\n      // 5th argument, $=selector engine, is deprecated and will be removed\n    , add = function (element, events, fn, delfn, $) {\n        var type, types, i, args\n          , originalFn = fn\n          , isDel = fn && typeof fn === 'string'\n\n        if (events && !fn && typeof events === 'object') {\n          for (type in events) {\n            if (events.hasOwnProperty(type))\n              add.apply(this, [ element, type, events[type] ])\n          }\n        } else {\n          args = arguments.length > 3 ? slice.call(arguments, 3) : []\n          types = (isDel ? fn : events).split(' ')\n          isDel && (fn = del(events, (originalFn = delfn), $ || selectorEngine)) && (args = slice.call(args, 1))\n          // special case for one()\n          this === ONE && (fn = once(remove, element, events, fn, originalFn))\n          for (i = types.length; i--;) addListener(element, types[i], fn, originalFn, args)\n        }\n        return element\n      }\n\n    , one = function () {\n        return add.apply(ONE, arguments)\n      }\n\n    , fireListener = W3C_MODEL ? function (isNative, type, element) {\n        var evt = doc.createEvent(isNative ? 'HTMLEvents' : 'UIEvents')\n        evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, win, 1)\n        element.dispatchEvent(evt)\n      } : function (isNative, type, element) {\n        element = targetElement(element, isNative)\n        // if not-native then we're using onpropertychange so we just increment a custom property\n        isNative ? element.fireEvent('on' + type, doc.createEventObject()) : element['_on' + type]++\n      }\n\n    , fire = function (element, type, args) {\n        var i, j, l, names, handlers\n          , types = type.split(' ')\n\n        for (i = types.length; i--;) {\n          type = types[i].replace(nameRegex, '')\n          if (names = types[i].replace(namespaceRegex, ''))\n            names = names.split('.')\n          if (!names && !args && element[eventSupport]) {\n            fireListener(nativeEvents[type], type, element)\n          } else {\n            // non-native event, either because of a namespace, arguments or a non DOM element\n            // iterate over all listeners and manually 'fire'\n            handlers = registry.get(element, type)\n            args = [false].concat(args)\n            for (j = 0, l = handlers.length; j < l; j++) {\n              if (handlers[j].inNamespaces(names))\n                handlers[j].handler.apply(element, args)\n            }\n          }\n        }\n        return element\n      }\n\n    , clone = function (element, from, type) {\n        var i = 0\n          , handlers = registry.get(from, type)\n          , l = handlers.length\n          , args, beanDel\n\n        for (;i < l; i++) {\n          if (handlers[i].original) {\n            beanDel = handlers[i].handler.__beanDel\n            if (beanDel) {\n              args = [ element, beanDel.selector, handlers[i].type, handlers[i].original, beanDel.$]\n            } else\n              args = [ element, handlers[i].type, handlers[i].original ]\n            add.apply(null, args)\n          }\n        }\n        return element\n      }\n\n    , bean = {\n          add: add\n        , one: one\n        , remove: remove\n        , clone: clone\n        , fire: fire\n        , setSelectorEngine: setSelectorEngine\n        , noConflict: function () {\n            context[name] = old\n            return this\n          }\n      }\n\n  if (win[attachEvent]) {\n    // for IE, clean up on unload to avoid leaks\n    var cleanup = function () {\n      var i, entries = registry.entries()\n      for (i in entries) {\n        if (entries[i].type && entries[i].type !== 'unload')\n          remove(entries[i].element, entries[i].type)\n      }\n      win[detachEvent]('onunload', cleanup)\n      win.CollectGarbage && win.CollectGarbage()\n    }\n    win[attachEvent]('onunload', cleanup)\n  }\n\n  return bean\n})\n\n//@ sourceURL=/node_modules/bean/bean.js"
));

require.define("/node_modules/prsr/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index\"}\n//@ sourceURL=/node_modules/prsr/package.json"
));

require.define("/node_modules/prsr/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/prsr')\n\n//@ sourceURL=/node_modules/prsr/index.js"
));

require.define("/node_modules/prsr/lib/prsr.js",Function(['require','module','exports','__dirname','__filename','process','global'],"void function(root){\n    \"use strict\"\n\n    var piper = require('piper')\n        , ONE, ZERO\n        , defaults = {}\n        , space = require('spce')\n        , symbols = {}\n        , tokens = []\n        , rat = require('rats')\n        ;\n\n//    piper.polyrat.prototype.toString = function(){\n//        var pretty = function(c){return c[0]+(c[1]?'':'/'+c[1])}\n//            , r\n//            ;\n//        if ( this[1].length = 1 && this[1][0] == piper([1]) ) {\n//            r = '(['+this[0].map(pretty).join(',')+'])'\n//        } else {\n//            r = '(['+this[0].map(pretty).join(',')+']/['+this[1].map(pretty).join(',')+'])'\n//        }\n//        return r\n//    }\n\n    function tokenize(input){\n        return tokenizer.call(input)\n    }\n\n    function tokenizer(){\n\n        if ( typeof this === \"undefined\" ||  this === null ) {\n            return\n        }\n\n        var c, from, i=0\n            , length, n\n            , result = []\n            , str = '', _ref\n            ;\n\n        length = this.length\n\n        function make(type, value){\n            return {\n                type: type,\n                value: value,\n                from: from,\n                to: i,\n                toString: function(){\n                    return value.toString()\n                }\n            }\n        }\n\n        c = this.charAt(i)\n\n        while ( c ) {\n            from = i\n            if ( c === ' ' ) {\n                i += 1\n                c = this.charAt(i)\n            } else if ( /[a-zA-Z]/.test(c) ) {\n                str = c\n                i += 1\n                while ( true ) {\n                    c = this.charAt(i)\n                    if ( /[0-9a-zA-Z]/.test(c) ) {\n                        str += c\n                        i += 1\n                    } else {\n                        break\n                    }\n                }\n                result.push(make('var', str))\n            } else if ( /[0-9]/.test(c) ) {\n                str = c\n                i += 1\n                while ( true ) {\n                    c = this.charAt(i)\n                    if ( !/[0-9]/.test(c) ) {\n                        break\n                    }\n                    i += 1\n                    str += c\n                }\n                if ( /[a-zA-Z]/.test(c) ) {\n                    str += c\n                    i += 1\n                    throw 'Bad number'\n                }\n                n = parseInt(str, 10)\n                if ( isFinite(n) ) {\n                    result.push(make('number', n))\n                } else {\n                    throw 'Bad number'\n                }\n            } else {\n                i += 1\n                result.push(make('operator', c))\n                c = this.charAt(i)\n            }\n        }\n        return result\n    }\n\n    function sybl(token, lvl, slv){\n        var x\n            ;\n        if ( lvl == null ) {\n            lvl = 1\n        }\n        this.lvl = lvl\n        this.toString = token.toString\n        x = extend(token, this)\n        switch ( x.type ) {\n            case  'var'  :\n                x = piper([0,1])\n                x.lvl = 1\n                break\n            case 'operator' :\n                x.slv = (slv != null)\n                                ? slv\n                                : (function() {\n                                    throw new Error('undefined operator')\n                                })\n                break\n            case  'number' :\n                x = piper([token.toString()])\n                x.lvl = 1\n                break\n        }\n        return x\n    }\n\n    function variable(name){\n        return space.push(name)\n    }\n\n    function symbolizer(token, lvl, slv){\n        return this[token.toString()] == null\n                        ? this[token.toString()] = new sybl(token, lvl, slv)\n                        : this[token.toString()]\n    }\n\n    function ct(str){\n        var t\n            ;\n        t = tokenize(str)\n        if ( str.length < 2 ) {\n            return t[0]\n        } else {\n            return t\n        }\n    }\n\n    function literal(tok){\n        var ctok, r\n            ;\n        if ( typeof tok === 'string' ) {\n            ctok = ct(tok)\n        } else {\n            ctok = tok\n        }\n        r = symbolizer.call(symbols, ctok, 1, (function(right){\n            return right\n        }))\n        return r\n    }\n\n    ZERO = literal(\"0\")\n\n    ONE = literal(\"1\")\n\n    symbolizer.call(defaults, ct(\"\\n\"), -1, (function(l, r){\n        if ( l == null ) {\n            l = ZERO\n        }\n        return literal(l)\n    }))\n\n    symbolizer.call(defaults, ct(\"+\"), 2, (function(l, r){\n        if ( l == null ) {\n            l = ZERO\n        }\n        if ( r == null ) {\n            r = ZERO\n        }\n        return literal(l.plus(r))\n    }))\n\n    symbolizer.call(defaults, ct(\"-\"), 2, (function(l, r){\n        var x\n            ;\n        if ( l == null ) {\n            l = ZERO\n        }\n        if ( r == null ) {\n            r = ZERO\n        }\n        x = literal(l.minus(r))\n        return x\n    }))\n\n    symbolizer.call(defaults, ct(\"*\"), 3, (function(l, r){\n        if ( l == null ) {\n            l = ONE\n        }\n        if ( r == null ) {\n            r = ONE\n        }\n        return literal(l.times(r))\n    }))\n\n    symbolizer.call(defaults, ct(\"/\"), 3, (function(l, r){\n        if ( l == null ) {\n            l = ONE\n        }\n        if ( r == null ) {\n            r = ONE\n        }\n        return literal(l.per(r))\n    }))\n\n    symbolizer.call(defaults, ct(\"^\"), 4, (function(l, r){\n        if ( l == null ) {\n            l = ONE\n        }\n        if ( r == null ) {\n            r = ZERO\n        }\n        //this is freakingly ugly\n        return literal(piper(l.pow(r[0][0])))\n    }))\n\n    symbolizer.call(defaults, ct(\")\"), 0, (function(l){\n        return literal(l)\n    }))\n\n    symbolizer.call(defaults, ct(\"(\"), 10, (function(l,r){\n        var e = expr(0)\n            ;\n        tokens.shift()\n        return e\n    }))\n\n    symbolizer.call(defaults, ct(\"=\"), 11, (function(l,r){\n        if ( l == null || r == null ) throw new Error ('equations have two sides' )\n        return null\n    }))\n\n    function symbolize(tokens){\n        var token, i, len\n            ;\n        symbols = extend({}, defaults)\n        for ( i = 0, len = tokens.length; i < len; i++ ) {\n            token = tokens[i]\n            symbolizer.call(symbols, token)\n        }\n        return symbols\n    }\n\n    function extend(obj){\n        Array.prototype.forEach.call(Array.prototype.slice.call(arguments, 1), function(source){\n            var prop\n                ;\n            for ( prop in source ) {\n                obj[prop] = source[prop]\n            }\n        })\n        return obj\n    }\n    function w(i){\n        var key =  (tokens[i] != null) ? tokens[i].toString() : void 0\n            ;\n        return symbols[key]\n    }\n\n    function c(i){\n        var key = tokens.splice(i, 1, null)[0]\n            ;\n        return symbols[key]\n    }\n\n    function x(i){\n        var key = tokens.splice(i, 1)[0]\n            ;\n        if ( key instanceof Int32Array ) {\n            return key\n        }\n        return symbols[key]\n    }\n\n    function g(i, o){\n        return tokens.splice(i, 1, o)\n    }\n\n    function t(i){\n        var _ref\n            ;\n        return (_ref = w(i)) != null ? _ref.type : void 0\n    }\n\n    function v(i){\n        var ref = w(i), ref1 = ref != null ? ref.lvl : void 0\n            ;\n        return ref1 != null ? ref1 : Number.MIN_VALUE\n    }\n\n    function isop(i){\n        return t(i) === 'operator'\n    }\n\n    function unry(i){\n        var operator, rhs, lhs = null, ret, paren = false\n            ;\n        operator = c(i)\n        if ( operator.lvl === 10 ) {\n            if ( i === 1 ) lhs = tokens.shift()\n            tokens.shift()\n            rhs = null\n            paren = true\n        } else if ( v(i+1) === 10 ) {\n            if ( i === 1 ) lhs = tokens.shift()\n            tokens.shift()\n            rhs = expr(0)\n            tokens.shift()\n            paren = true\n        } else if ( ! isop(i + 1) ) {\n            rhs = x(i + 1)\n        } else {\n            rhs = null\n        }\n        if ( paren ) {\n            ret = tokens.splice(0, 0, operator.slv(null, rhs))\n            if ( lhs !== null ) tokens.splice(0, 0, lhs)\n        } else {\n            ret = g(i, operator.slv(null, rhs))\n        }\n        return ret\n    }\n\n    function expr(lvl){\n        var l = isop(0) ? null : x(0), nextop, operator, r\n            ;\n\n        while ( isop(0) && v(0) > lvl ) {\n            while ( isop(1) && v(0) !== 10 && v(1) !== 10 ) {\n                unry(1)\n                if ( l == null ) {\n                    unry(0)\n                    l = x(0)\n                }\n            }\n            if ( isop(0) ) {\n                operator = x(0)\n                if ( operator.lvl !== 10 ) {\n                    r = !isop(0) ? w(0) : null\n                    nextop = r != null ? 1 : 0\n                }\n                if ( v(nextop) <= operator.lvl ) {\n                    if (r != null) {\n                        x(0)\n                    }\n                } else {\n                    r = expr(operator.lvl)\n                }\n                l = operator.slv(l, r)\n            }\n        }\n        return l\n    }\n\n    function parse(input){\n        var counter, e\n            ;\n        tokens = tokenize(input)\n        symbols = symbolize(tokens)\n        space.del('input')\n        counter = 0\n        while ( tokens.length > 0 ) {\n            e = expr(-1)\n            space.push('input', e)\n            if ( typeof tokens[0] !== 'undefined'\n                && typeof symbols[tokens[0].value] !== 'undefined'\n                && symbols[tokens[0].value].lvl === -1 ) {\n                    tokens.shift()\n            }\n            if (++counter > 100) {\n                throw new Error('possible infinite loop')\n            }\n        }\n        return space.get('input')\n    }\n    if ( typeof module != 'undefined' && module.exports ) {\n        module.exports = parse\n    } else {\n        root.factory = parse\n    }\n\n}(this)\n\n//@ sourceURL=/node_modules/prsr/lib/prsr.js"
));

require.define("/node_modules/piper/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/piper/package.json"
));

require.define("/node_modules/piper/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/piper');\n\n//@ sourceURL=/node_modules/piper/index.js"
));

require.define("/node_modules/piper/lib/piper.js",Function(['require','module','exports','__dirname','__filename','process','global'],"void function(root){\n    \"use strict\"\n\n    var num\n        , pns = {}\n        , rats = require('rats')\n        ;\n\n    function isInt(input){\n        return typeof input !== 'object' && parseInt(input, 10) == input\n    }\n\n\n    function convertToInt(input){\n        if ( isInt(input) ) {\n            return parseInt(input, 10)\n        } else {\n            throw new Error('bad format: '+input+(' ('+typeof input+')'))\n        }\n    }\n\n    function rtrim(arr){\n        while ( arr.length > 1 && arr[arr.length-1] === 0  ) {\n            arr.pop()\n        }\n        return arr\n    }\n\n    function largestNonZeroIndex(arr){\n        var len = arr.length\n            , i, t;\n        for ( i=0; i<len; i++ ) {\n            if ( Math.abs(arr[i]) > 0) {\n                if ( t === undefined ) t = 0\n                if ( i > t ) t = i\n            }\n        }\n        return t\n    }\n\n    function degree(arr){\n        if ( arr == null && this == null ) {\n            throw new Error('missing argument')\n        }\n\n        var arr = (arr == null) ? this : arr\n            , t1, t2\n            ;\n\n        if ( arr instanceof polyrat ) {\n            t1 = largestNonZeroIndex(arr[0])\n            t2 = largestNonZeroIndex(arr[1])\n            return t1 > t2 ? t1 : t2\n        } else if ( Array.isArray(arr) ) {\n            return largestNonZeroIndex(arr)\n        } else {\n            throw new Error('dafuq')\n        }\n    }\n\n\n    function divide(p, q){\n        var n, u, v, k, j, s=[], r=[]\n            , pdeg = degree(p), qdeg = degree(q)\n            , slcm, ulcm\n            , divisor\n            ;\n\n        u = p.slice(0).map(rats.checkInput)\n        v = q.slice(0).map(rats.checkInput)\n        for ( k = pdeg - qdeg ; k >= 0 ; k-- ) {\n            s[k] = u[qdeg+k].per(v[qdeg])\n            for ( j = qdeg + k  ; j >= k ; j-- ) {\n                u[j] = u[j].minus(s[k].times(v[j-k]))\n            }\n        }\n        slcm = s.map(function(o){return o[1]}).reduce(function(p,c){\n            return p===0?c:(p*c/rats.gcd(p,c))\n        })\n\n        ulcm = u.map(function(o){return o[1]}).reduce(function(p,c,i){\n            return p===0?c:(p*c/rats.gcd(p,c))\n        })\n\n        s = s.map(function(v){ return (slcm / v[1]) * v[0] * ulcm })\n        u = u.map(function(v){ return (ulcm / v[1]) * v[0] * slcm })\n\n        divisor = s.concat(u).map(function(o){return o[0]}).reduce(function(p,c){\n            return p===0?c:(rats.gcd(p,c))\n        })\n\n        s = rtrim(s.map(function(v){v[0] = v[0]/divisor; return v}))\n        u = rtrim(u.map(function(v){v[0] = v[0]/divisor; return v}))\n\n        return [s,u]\n    }\n\n    function gcd(p, q){\n        var f = p, g = q,s, t, w=1;\n        while ( degree(f) > 0 && degree(g) > 0 )  {\n            t = g\n            s = divide(f, g)\n            if ( degree(s[1]) === undefined ) return piper(t)\n            g = s[1]\n            f = t\n        }\n        return piper([1])\n    }\n\n    function hashify(){\n        return '['+this[0].join(',')+']/['+this[1].join(',')+']'\n    }\n\n    function display(){\n        //rats display el van baszodva\n        //console.log(rats(this[0][0], this[1][0]).display()) // rahhh\n        return this.degree() === 0\n                ? rats(this[0][0], this[1][0]).display()\n                : '['+this[0].join(',')+']/['+this[1].join(',')+']'\n    }\n\n    function plus(input, input2){\n        var len, i, l, r, result=[];\n\n        len = input.length > input2.length ? input.length : input2.length\n\n        for ( i = 0; i < len; i++ ) {\n            l = input[i] !== undefined ? input[i] : 0\n            r = input2[i] !== undefined ? input2[i] : 0\n            result[i] = l+r\n        }\n        return result\n    }\n\n    function minus(input, input2){\n        var len, i, l, r, result=[];\n        len = input.length > input2.length ? input.length : input2.length\n        for ( i = 0; i < len; i++ ) {\n            l = input[i] !== undefined ? input[i] : 0\n            r = input2[i] !== undefined ? input2[i] : 0\n            result[i] = l-r\n        }\n        return result\n    }\n\n    function times(input, input2){\n        var p, plen, q, qlen, i, j, result=[];\n        p = input.slice(0)\n        plen = input.length\n        q = input2.slice(0)\n        qlen = input2.length\n        for ( i=0; i<plen; i++ ) {\n            for ( j=0; j<qlen; j++ ) {\n                if ( result[i+j] === undefined ) result[i+j] = 0\n                if ( p[i+j] === undefined ) p[i+j] = 0\n                if ( q[i+j] === undefined ) q[i+j] = 0\n                result[i+j] = result[i+j]+(p[i]*q[j])\n            }\n        }\n        return result\n    }\n\n    function per(input, input2){\n        var result\n            , f = input instanceof polyrat\n            , s = input2 instanceof polyrat\n            , t = null\n            ;\n        if ( f && s ) {\n            result = divide(input, input2)\n        //} else if ( f && !s) {\n        //    result = input.per(piper(input2))\n        //} else if ( !f && s) {\n        //    result = piper(input).per(input2)\n        } else {\n            result = piper(input, input2)\n        }\n        return result\n    }\n\n    function pow(input, input2){\n        var i, result=[];\n        if ( ! isInt( input2 ) ) {\n            throw new Error('undefined operation, look for roots elsewhere')\n        }\n        i=0\n        result = input\n        if ( input2 !== 0 ) {\n            while ( ++i < input2 ) {\n                result = result.times(input)\n            }\n        } else {\n            result = piper([1])\n        }\n        return result\n    }\n\n    function val(input, input2){\n        var n = piper([0])\n            , d = piper([0])\n            , len\n            , i\n            , t1\n            , t2\n            ;\n        if ( ! ( input2 instanceof polyrat ) ) {\n            if ( Array.isArray(input2) ) {\n                input2 = piper(input2)\n            } else {\n                input2 = piper([input2])\n            }\n        }\n        len = input[0].length\n        for ( i=0; i < len; i++ ) {\n            t1 = piper([input[0][i]])\n            t2 = piper(input2.pow(i))\n            n = n.plus(t1.times(t2))\n        }\n        len = input[1].length\n        for ( i=0; i < len; i++ ) {\n            t1 = piper([input[1][i]])\n            t2 = piper(input2.pow(i))\n            d = d.plus(t1.times(t2))\n        }\n        return piper(n, d)\n    }\n\n    function polyrat(){}\n\n    polyrat.prototype.hashify = display\n\n    polyrat.prototype.toString = display\n\n    polyrat.prototype.degree = degree\n\n    polyrat.prototype.display = display\n\n    polyrat.prototype.plus = function(input){\n        var p = this[0]\n            , q = this[1]\n            , r = input[0]\n            , s = input[1]\n            ;\n        return per(plus(times(p, s), times(r, q)), times(q, s))\n    }\n\n    polyrat.prototype.minus = function(input){\n        var p = this[0]\n            , q = this[1]\n            , r = input[0]\n            , s = input[1]\n            ;\n        return per(minus(times(p, s), times(r, q)), times(q, s))\n    }\n    polyrat.prototype.times = function(input){\n\n        var p = this[0]\n            , q = this[1]\n            , r = input[0]\n            , s = input[1]\n            , n = times(p, r)\n            , d = times(q, s)\n            ;\n\n        return per(n, d)\n    }\n    polyrat.prototype.pow = function (input){\n        return pow(this, input)\n    }\n    polyrat.prototype.val = function (input){\n        return val(this, input)\n    }\n    polyrat.prototype.per = function (input){\n        var p = this[0]\n            , q = this[1]\n            , r = input[0]\n            , s = input[1]\n            , n = times(p, s)\n            , d = times(r, q)\n            ;\n        return per(n, d)\n    }\n    polyrat.prototype.divide = function (input){\n        return divide(this, input)\n    }\n    polyrat.prototype.leftTr = function (input){\n        return val(this,piper([input,1]))\n    }\n    polyrat.prototype.compose = function (input){\n        return compose(this, input)\n    }\n\n\n    function piper(numerator, denominator){\n        var key, idx, t, len, i, n, j, d, intvals, dd, divisor;\n\n        if ( numerator instanceof polyrat ) {\n            if ( denominator == null ) {\n                return numerator\n            } else if ( denominator instanceof polyrat) {\n                n = times(numerator[0], denominator[1])\n                d = times(denominator[0], numerator[1])\n                numerator = n\n                denominator = d\n            }\n        }\n\n        if ( ! Array.isArray(numerator) ) {\n            throw new Error('invalid argument, array expected instead of '+\n                    numerator+' ('+typeof numerator+')')\n        } else {\n            numerator = numerator.map(convertToInt)\n        }\n\n        denominator = Array.isArray(denominator)\n                        ? denominator.map(convertToInt)\n                        : [1]\n\n        dd = largestNonZeroIndex(denominator)\n\n        if ( dd  === undefined ) {\n            throw new Error('the denominator must not equal 0')\n        }\n\n        numerator = rtrim(numerator)\n        denominator = rtrim(denominator)\n        if ( dd > 0 ) {\n            divisor = gcd(numerator, denominator)\n            if ( Math.abs(degree(divisor[0])) > 0 || divisor[0][0] !== 1 ) {\n                numerator = divide(numerator, divisor[0])[0]\n                denominator = divide(denominator, divisor[0])[0]\n            }\n        }\n\n        if ( numerator.length === 1 && Math.abs(numerator[0]) === 0 ) {\n            denominator = [1]\n        }\n\n        divisor = numerator.concat(denominator).reduce(function(p,c){\n            return p===0?c:(rats.gcd(p,c))\n        })\n\n        divisor = denominator[denominator.length-1] * divisor < 0\n                                            ? divisor * -1\n                                            : divisor\n\n        numerator = rtrim(numerator.map(function(v){ return v/divisor}))\n        denominator = rtrim(denominator.map(function(v){ return v/divisor}))\n\n        idx = '['+numerator.join(',')+']/['+denominator.join(',')+']'\n\n        if ( pns[idx] === undefined ) {\n            pns[idx] = new polyrat\n            pns[idx][0] = numerator\n            pns[idx][1] = denominator\n        }\n\n\n        return pns[idx]\n    }\n\n    piper.polyrat = polyrat\n\n    if ( module != undefined && module.exports )\n        module.exports = piper\n    else\n        root.factory = piper\n\n}(this)\n\n//@ sourceURL=/node_modules/piper/lib/piper.js"
));

require.define("/node_modules/rats/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rats/package.json"
));

require.define("/node_modules/rats/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/rats');\n\n//@ sourceURL=/node_modules/rats/index.js"
));

require.define("/node_modules/rats/lib/rats.js",Function(['require','module','exports','__dirname','__filename','process','global'],"void function(root){\n    \"use strict\"\n\n    var numbers = {};\n\n    function isInt(input){\n        return typeof input !== 'object' && parseInt(input, 10) == input\n    }\n\n\n    function checkInput(input){\n        if ( input instanceof Int32Array && input.byteLength === 8 ) {\n            return input\n        }\n        return rat(input)\n    }\n\n    function gcd(a, b){\n        var t;\n        a = Math.abs(a)\n        b = Math.abs(b)\n        while (b > 0) {\n            t = b\n            b = a % b\n            a = t\n        }\n        return a\n    }\n\n    function hashify(){\n        return this[0]+'/'+this[1]\n    }\n\n    function display(){\n        return ''+this[0]+(this[1]!=1?'/'+this[1]:'')\n    }\n\n    function val(){\n        return this[0]/this[1]\n    }\n\n    function plus(x){\n        x = checkInput(x)\n        return rat(this[0]*x[1]+x[0]*this[1], this[1]*x[1])\n    }\n\n    function minus(x){\n        x = checkInput(x)\n        return rat(this[0]*x[1]-x[0]*this[1], this[1]*x[1])\n    }\n\n    function times(x){\n        x = checkInput(x)\n        return rat(this[0]*x[0], this[1]*x[1])\n    }\n\n    function per(x){\n        x = checkInput(x)\n        return rat(this[0]*x[1], x[0]*this[1])\n    }\n\n    function rat(numerator, denominator){\n\n        var index, divisor;\n\n        if ( ! isInt(numerator) ) {\n            throw new Error('invalid argument '+numerator+' ('+(typeof numerator)+')')\n        } else if ( typeof numerator === 'string' ) {\n            numerator = parseInt(numerator, 10)\n        }\n\n        if ( ! isInt(denominator) ) {\n            denominator = 1\n        } else if ( typeof denominator === 'string' ) {\n            denominator = parseInt(denominator, 10)\n        }\n\n        if ( denominator == 0 ) {\n            throw new Error('the denominator must not equal 0')\n        }\n\n        divisor = gcd(numerator, denominator)\n        if ( Math.abs(divisor) > 1 ) {\n            numerator = numerator / divisor\n            denominator = denominator / divisor\n        }\n\n        if ( denominator < 0 ) {\n            numerator *= -1\n            denominator *= -1\n        }\n\n        index = hashify.call([numerator, denominator])\n\n        if ( numbers[index] === undefined ) {\n            numbers[index] = new Int32Array(2)\n            numbers[index][0] = numerator\n            numbers[index][1] = denominator\n            numbers[index].toString = hashify\n            numbers[index].display = display\n            numbers[index].val = val\n            numbers[index].plus = plus\n            numbers[index].minus = minus\n            numbers[index].times = times\n            numbers[index].per = per\n        }\n\n        return numbers[index]\n\n    }\n\n    rat.isInt = isInt\n    rat.checkInput = checkInput\n    rat.gcd = gcd\n\n    if ( typeof module !== 'undefined' && module.exports ) {\n        module.exports = rat\n    } else {\n        root.factory = rat\n    }\n\n}(this)\n\n//@ sourceURL=/node_modules/rats/lib/rats.js"
));

require.define("/node_modules/spce/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index\"}\n//@ sourceURL=/node_modules/spce/package.json"
));

require.define("/node_modules/spce/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// This file is just added for convenience so this repository can be\n// directly checked out into a project's deps folder\nmodule.exports = require('./lib/spce');\n\n//@ sourceURL=/node_modules/spce/index.js"
));

require.define("/node_modules/spce/lib/spce.js",Function(['require','module','exports','__dirname','__filename','process','global'],"void function(root){\n\n    var spce,  expr, newkey, privkeys, variable, variables\n        ;\n\n    spce = {\n        init: function () {\n            return this\n        }\n        , add : function(value) {\n            return variable(newkey(), value)\n        }\n\n        , get : function(key) {\n            return variables[key]\n        }\n\n        , del : function(key) {\n            return variables[key] = void 0\n        }\n\n        , push : function(key, value) {\n            var arr\n                ;\n            arr = variables[key]\n            if (!(arr != null)) {\n                arr = []\n            }\n            arr.push(value)\n            return variables[key] = arr\n        }\n\n        , variable : variable\n\n        , variables : variables\n\n    }\n\n    privkeys = []\n\n    //expr = luma.factory({\n    //    init: function() {\n\n    //        function expr(value) {\n    //            this.body = function() {\n    //                return value\n    //            }\n    //        }\n\n    //        expr.prototype.eq = []\n\n    //        expr.prototype.gt = []\n\n    //        expr.prototype.lt = []\n\n    //        expr.prototype.body = []\n\n    //        expr.prototype.func = function() {\n    //            var vars\n    //            vars = 1 <= arguments.length ? Array.prototype.slice.call(arguments, 0) : []\n    //        }\n\n\n    //        return expr\n    //    }\n\n    //})\n\n    newkey = function() {\n        var s\n            ;\n        s = 'var' + privkeys.length\n        privkeys.push(s)\n        return s\n    }\n\n    variables = {}\n\n    variable = function(key, value) {\n        if (typeof key === 'undefined' || typeof value === 'undefined') {\n            return null\n        }\n        if (!(variables[key] != null)) {\n            variables[key] = value\n        }\n        return variables[key]\n    }\n\n    if ( typeof module != 'undefined' && module.exports ) {\n        module.exports = spce\n    } else {\n        root.factory = spce\n    }\n}(this)\n\n//@ sourceURL=/node_modules/spce/lib/spce.js"
));

require.define("/right.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\"use strict\"\nvoid function(root){\n\n    var ratjs\n\n    ratjs = (function() {\n        var bean = require('bean')\n            , prsr = require('prsr')\n            ;\n\n        function ratjs(){}\n\n        function tic(e) {\n            var result, lines = '', i, reslen\n                , num\n                , den\n                , out = document.getElementById('output')\n                ;\n            try {\n                result = prsr(e.currentTarget.value + \"\\n\")\n            } catch (e) {\n                return out.innerHTML = e.message\n            }\n\n            reslen = result.length\n            for ( i = 0; i < reslen ; i++ ) {\n                console.log('o',result)\n                lines += result[i].display()\n                lines +='<br/>'\n            }\n            out.innerHTML = lines\n            return\n        }\n\n        ratjs.watch = function(id) {\n            return bean.one(window, 'load', function() {\n                var elem;\n                elem = document.getElementById(id)\n                if ( elem != null ) return bean.add(elem, 'keyup', tic)\n            })\n        }\n\n        return ratjs\n\n    })()\n\n    ratjs.watch('input')\n\n}(this)\n\n//@ sourceURL=/right.js"
));
require("/right.js");
})();
