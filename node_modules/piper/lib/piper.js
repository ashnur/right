void function(root){
    "use strict"

    var num
        , pns = {}
        , rats = require('rats')
        ;

    function isInt(input){
        return typeof input !== 'object' && parseInt(input, 10) == input
    }


    function convertToInt(input){
        if ( isInt(input) ) {
            return parseInt(input, 10)
        } else {
            throw new Error('bad format: '+input+(' ('+typeof input+')'))
        }
    }

    function rtrim(arr){
        while ( arr.length > 1 && arr[arr.length-1] === 0  ) {
            arr.pop()
        }
        return arr
    }

    function largestNonZeroIndex(arr){
        var len = arr.length
            , i, t;
        for ( i=0; i<len; i++ ) {
            if ( Math.abs(arr[i]) > 0) {
                if ( t === undefined ) t = 0
                if ( i > t ) t = i
            }
        }
        return t
    }

    function degree(arr){
        if ( arr == null && this == null ) {
            throw new Error('missing argument')
        }

        var arr = (arr == null) ? this : arr
            , t1, t2
            ;

        if ( arr instanceof polyrat ) {
            t1 = largestNonZeroIndex(arr[0])
            t2 = largestNonZeroIndex(arr[1])
            return t1 > t2 ? t1 : t2
        } else if ( Array.isArray(arr) ) {
            return largestNonZeroIndex(arr)
        } else {
            throw new Error('dafuq')
        }
    }


    function divide(p, q){
        var n, u, v, k, j, s=[], r=[]
            , pdeg = degree(p), qdeg = degree(q)
            , slcm, ulcm
            , divisor
            ;

        u = p.slice(0).map(rats.checkInput)
        v = q.slice(0).map(rats.checkInput)
        for ( k = pdeg - qdeg ; k >= 0 ; k-- ) {
            s[k] = u[qdeg+k].per(v[qdeg])
            for ( j = qdeg + k  ; j >= k ; j-- ) {
                u[j] = u[j].minus(s[k].times(v[j-k]))
            }
        }
        slcm = s.map(function(o){return o[1]}).reduce(function(p,c){
            return p===0?c:(p*c/rats.gcd(p,c))
        })

        ulcm = u.map(function(o){return o[1]}).reduce(function(p,c,i){
            return p===0?c:(p*c/rats.gcd(p,c))
        })

        s = s.map(function(v){ return (slcm / v[1]) * v[0] * ulcm })
        u = u.map(function(v){ return (ulcm / v[1]) * v[0] * slcm })

        divisor = s.concat(u).map(function(o){return o[0]}).reduce(function(p,c){
            return p===0?c:(rats.gcd(p,c))
        })

        s = rtrim(s.map(function(v){v[0] = v[0]/divisor; return v}))
        u = rtrim(u.map(function(v){v[0] = v[0]/divisor; return v}))

        return [s,u]
    }

    function gcd(p, q){
        var f = p, g = q,s, t, w=1;
        console.log(p,q)
        while ( degree(f) > 0 && degree(g) > 0 )  {
            t = g
            s = divide(f, g)
            console.log('gcd', f,g, degree(s[1]), s, t)
            if ( degree(s[1]) === undefined ) return piper(t)
            g = s[1]
            f = t
        }
        return piper([1])
    }

    function hashify(){
        return '['+this[0].join(',')+']/['+this[1].join(',')+']'
    }

    function display(){
        //rats display el van baszodva
        //console.log(rats(this[0][0], this[1][0]).display()) // rahhh
        return this.degree() === 0
                ? rats(this[0][0], this[1][0]).display()
                : '['+this[0].join(',')+']/['+this[1].join(',')+']'
    }

    function plus(input, input2){
        var len, i, l, r, result=[];

        len = input.length > input2.length ? input.length : input2.length

        for ( i = 0; i < len; i++ ) {
            l = input[i] !== undefined ? input[i] : 0
            r = input2[i] !== undefined ? input2[i] : 0
            result[i] = l+r
        }
        return result
    }

    function minus(input, input2){
        var len, i, l, r, result=[];
        len = input.length > input2.length ? input.length : input2.length
        for ( i = 0; i < len; i++ ) {
            l = input[i] !== undefined ? input[i] : 0
            r = input2[i] !== undefined ? input2[i] : 0
            result[i] = l-r
        }
        return result
    }

    function times(input, input2){
        var p, plen, q, qlen, i, j, result=[];
        p = input.slice(0)
        plen = input.length
        q = input2.slice(0)
        qlen = input2.length
        for ( i=0; i<plen; i++ ) {
            for ( j=0; j<qlen; j++ ) {
                if ( result[i+j] === undefined ) result[i+j] = 0
                if ( p[i+j] === undefined ) p[i+j] = 0
                if ( q[i+j] === undefined ) q[i+j] = 0
                result[i+j] = result[i+j]+(p[i]*q[j])
            }
        }
        return result
    }

    function per(input, input2){
        var result
            , f = input instanceof polyrat
            , s = input2 instanceof polyrat
            , t = null
            ;
        if ( f && s ) {
            result = divide(input, input2)
        //} else if ( f && !s) {
        //    result = input.per(piper(input2))
        //} else if ( !f && s) {
        //    result = piper(input).per(input2)
        } else {
            result = piper(input, input2)
        }
        return result
    }

    function pow(input, input2){
        var i, result=[];
        if ( ! isInt( input2 ) ) {
            throw new Error('undefined operation, look for roots elsewhere')
        }
        i=0
        result = input
        if ( input2 !== 0 ) {
            while ( ++i < input2 ) {
                result = result.times(input)
            }
        } else {
            result = piper([1])
        }
        return result
    }

    function val(input, input2){
        var n = piper([0])
            , d = piper([0])
            , len
            , i
            , t1
            , t2
            ;
        if ( ! ( input2 instanceof polyrat ) ) {
            if ( Array.isArray(input2) ) {
                input2 = piper(input2)
            } else {
                input2 = piper([input2])
            }
        }
        len = input[0].length
        for ( i=0; i < len; i++ ) {
            t1 = piper([input[0][i]])
            t2 = piper(input2.pow(i))
            n = n.plus(t1.times(t2))
        }
        len = input[1].length
        for ( i=0; i < len; i++ ) {
            t1 = piper([input[1][i]])
            t2 = piper(input2.pow(i))
            d = d.plus(t1.times(t2))
        }
        return piper(n, d)
    }

    function polyrat(){}

    polyrat.prototype.hashify = display

    polyrat.prototype.toString = display

    polyrat.prototype.degree = degree

    polyrat.prototype.display = display

    polyrat.prototype.plus = function(input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            ;
        return per(plus(times(p, s), times(r, q)), times(q, s))
    }

    polyrat.prototype.minus = function(input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            ;
        return per(minus(times(p, s), times(r, q)), times(q, s))
    }
    polyrat.prototype.times = function(input){

        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            , n = times(p, r)
            , d = times(q, s)
            ;

        return per(n, d)
    }
    polyrat.prototype.pow = function (input){
        return pow(this, input)
    }
    polyrat.prototype.val = function (input){
        return val(this, input)
    }
    polyrat.prototype.per = function (input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            , n = times(p, s)
            , d = times(r, q)
            ;
        return per(n, d)
    }
    polyrat.prototype.divide = function (input){
        return divide(this, input)
    }
    polyrat.prototype.leftTr = function (input){
        return val(this,piper([input,1]))
    }
    polyrat.prototype.compose = function (input){
        return compose(this, input)
    }


    function piper(numerator, denominator){
        var key, idx, t, len, i, n, j, d, intvals, dd, divisor;

        if ( numerator instanceof polyrat ) {
            if ( denominator == null ) {
                return numerator
            } else if ( denominator instanceof polyrat) {
                n = times(numerator[0], denominator[1])
                d = times(denominator[0], numerator[1])
                numerator = n
                denominator = d
            }
        }

        if ( ! Array.isArray(numerator) ) {
            throw new Error('invalid argument, array expected instead of '+
                    numerator+' ('+typeof numerator+')')
        } else {
            numerator = numerator.map(convertToInt)
        }

        denominator = Array.isArray(denominator)
                        ? denominator.map(convertToInt)
                        : [1]

        dd = largestNonZeroIndex(denominator)

        if ( dd  === undefined ) {
            throw new Error('the denominator must not equal 0')
        }

        numerator = rtrim(numerator)
        denominator = rtrim(denominator)
        if ( dd > 0 ) {
            divisor = gcd(numerator, denominator)
            if ( Math.abs(degree(divisor[0])) > 0 || divisor[0][0] !== 1 ) {
                numerator = divide(numerator, divisor[0])[0]
                denominator = divide(denominator, divisor[0])[0]
            }
        }

        if ( numerator.length === 1 && Math.abs(numerator[0]) === 0 ) {
            denominator = [1]
        }

        divisor = numerator.concat(denominator).reduce(function(p,c){
            return p===0?c:(rats.gcd(p,c))
        })

        divisor = denominator[denominator.length-1] * divisor < 0
                                            ? divisor * -1
                                            : divisor

        numerator = rtrim(numerator.map(function(v){ return v/divisor}))
        denominator = rtrim(denominator.map(function(v){ return v/divisor}))

        idx = '['+numerator.join(',')+']/['+denominator.join(',')+']'

        if ( pns[idx] === undefined ) {
            pns[idx] = new polyrat
            pns[idx][0] = numerator
            pns[idx][1] = denominator
        }


        return pns[idx]
    }

    piper.polyrat = polyrat

    if ( module != undefined && module.exports )
        module.exports = piper
    else
        root.factory = piper

}(this)
