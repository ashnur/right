void function(root){
    "use strict"

    var num, pns = {}, rat;

    rat = require('rats')

    function rtrim(arr){
        while ( arr.length > 1 && arr[arr.length-1] === rat(0)  ) {
            arr.pop()
        }
        return arr
    }

    function checkForZero(arr){
        var len = arr.length
            , i, r, t;
        for ( i=0; i<len; i++ ) {
            if ( typeof arr[i].val !== 'undefined' ) {
                r = Math.abs(arr[i].val())
            } else {
                r = Math.abs(arr[i])
            }
            if ( typeof r !== 'undefined' ) {
                if ( r > 0  ) {
                    if ( typeof t === 'undefined' ) t = 0
                    if ( i > t ) t = i
                }
            }
        }
        return t
    }

    function degree(arr){
        if ( typeof arr === 'undefined' && typeof this === 'undefined' ) {
            throw new Error('missing argument')
        }
        var arr = (typeof arr === 'undefined') ? this : arr
            , t1, t2 ;
            if ( arr instanceof polyrat ) {
                t1 = checkForZero(arr[0])
                t2 = checkForZero(arr[1])
            } else if ( Array.isArray(arr) ) {
                return checkForZero(arr)
            } else {
                throw new Error('dafuq')
            }
        return t1 > t2 ? t1 : t2
    }

    function divide(p, q){
        var n, u, v, k, j, s=[], r=[]
            , pdeg = degree(p), qdeg = degree(q);
        u = p.slice(0)
        v = q.slice(0)
        for ( k = pdeg - qdeg ; k >= 0 ; k-- ) {
            s[k] = u[qdeg+k].per(v[qdeg])
            for ( j = qdeg + k  ; j >= k ; j-- ) {
                u[j] = u[j].minus(s[k].times(v[j-k]))
            }
        }
        s = rtrim(s)
        u = rtrim(u)
        return [s,u]
    }

    function gcd(p, q){
        var f = p, g = q,s, t, w=1;
        while ( degree(f) > 0 && degree(g) > 0 )  {
            t = g
            s = divide(f, g)
            if ( typeof degree(s[1]) === 'undefined' ) return piper(t)
            g = s[1]
            f = t
        }
        return piper([1])
    }

    function hashify(){
        return '['+this[0].join(',')+']/['+this[1].join(',')+']'
    }

    function plus(input, input2){
        var len, i, l, r, result=[];
        if ( input.length > input2.length ) {
            len = input.length
        } else {
            len = input2.length
        }
        for ( i = 0; i < len; i++ ) {
            l = typeof input[i] !== 'undefined' ? input[i] : rat(0)
            r = typeof input2[i] !== 'undefined' ? input2[i] : rat(0)
            result[i] = l.plus(r)
        }
        return result
    }

    function minus(input, input2){
        var len, i, l, r, result=[];
        if ( input.length > input2.length ) {
            len = input.length
        } else {
            len = input2.length
        }
        for ( i = 0; i < len; i++ ) {
            l = typeof input[i] !== 'undefined' ? input[i] : rat(0)
            r = typeof input2[i] !== 'undefined' ? input2[i] : rat(0)
            result[i] = l.minus(r)
        }
        return result
    }

    function times(input, input2){
        var p, plen, q, qlen, i, j, result=[];
        p = input.slice(0)
        plen = input.length
        q = input2.slice(0)
        qlen = input2.length
        for ( i=0; i<plen; i++ ){
            for ( j=0; j<qlen; j++ ){
                if ( typeof result[i+j] === 'undefined' ) result[i+j] = rat(0)
                if ( typeof p[i+j] === 'undefined' ) p[i+j] = rat(0)
                if ( typeof q[i+j] === 'undefined' ) q[i+j] = rat(0)

                result[i+j] = result[i+j].plus(p[i].times(q[j]))
            }
        }
        return result
    }

    function per(input, input2){
        var result
            , f = input instanceof polyrat
        , s = input2 instanceof polyrat
            , t = null
            ;
        if ( f && s ) {
            result = divide(input, input2)
        //} else if ( f && !s) {
        //    result = input.per(piper(input2))
        //} else if ( !f && s) {
        //    result = piper(input).per(input2)
        } else {
            result = piper(input, input2)
        }
        return result
    }

    function pow(input, input2){
        var i, result=[];
        if ( ! rat.isInt( input2 ) ) {
            throw new Error('undefined operation, look for roots elsewhere')
        }
        i=0
        result = input
        if ( input2 !== 0 ) {
            while ( ++i < input2 ) {
                result = result.times(input)
            }
        } else {
            result = piper([1])
        }
        return result
    }

    function val(input, input2){
        var n = piper([0])
            , d = piper([0])
            , len
            , i
            , t1
            , t2
            ;
        if ( ! ( input2 instanceof polyrat ) ) {
            if ( Array.isArray(input2) ) {
                input2 = piper(input2)
            } else {
                input2 = piper([input2])
            }
        }
        len = input[0].length
        for ( i=0; i < len; i++ ) {
            t1 = piper([input[0][i]])
            t2 = piper(input2.pow(i))
            n = n.plus(t1.times(t2))
        }
        len = input[1].length
        for ( i=0; i < len; i++ ) {
            t1 = piper([input[1][i]])
            t2 = piper(input2.pow(i))
            d = d.plus(t1.times(t2))
        }
        return piper(n, d)
    }

    function polyrat(){}

    polyrat.prototype.hashify = hashify

    polyrat.prototype.toString = hashify

    polyrat.prototype.degree = degree

    polyrat.prototype.plus = function(input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            ;
        return per(plus(times(p, s), times(r, q)), times(q, s))
    }

    polyrat.prototype.minus = function(input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            ;
        return per(minus(times(p, s), times(r, q)), times(q, s))
    }
    polyrat.prototype.times = function(input){

        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            , n = times(p, r)
            , d = times(q, s)
            ;

        return per(n, d)
    }
    polyrat.prototype.pow = function (input){
        return pow(this, input)
    }
    polyrat.prototype.val = function (input){
        return val(this, input)
    }
    polyrat.prototype.per = function (input){
        var p = this[0]
            , q = this[1]
            , r = input[0]
            , s = input[1]
            , n = times(p, s)
            , d = times(r, q)
            ;
        return per(n, d)
    }
    polyrat.prototype.divide = function (input){
        return divide(this, input)
    }
    polyrat.prototype.leftTr = function (input){
        return val(this,piper([input,1]))
    }
    polyrat.prototype.compose = function (input){
        return compose(this, input)
    }


    function piper(numerator, denominator){
        var key, idx, t, len, i, n, j, d, intvals, dd, divisor;


        if ( numerator instanceof polyrat ) {
            if ( typeof denominator == 'undefined' ) {
                return numerator
            } else if ( denominator instanceof polyrat) {
                n = times(numerator[0], denominator[1])
                d = times(denominator[0], numerator[1])
                numerator = n
                denominator = d
            }
        }

        if ( ! Array.isArray(numerator) ) {
            throw new Error('invalid argument, array expected instead of '+
                    numerator+' ('+typeof numerator+')')
        } else {
            numerator = numerator.map(rat.checkInput)
        }

        if ( ! Array.isArray(denominator) ) {
            denominator = [rat(1)]
        } else {
            denominator = denominator.map(rat.checkInput)
        }
        dd = checkForZero(denominator)
        if ( typeof dd  === 'undefined' ) {
            throw new Error('the denominator must not equal 0')
        }

        numerator = rtrim(numerator)
        denominator = rtrim(denominator)

        if (  Math.abs(denominator[0].val()) !== 1 ) {
            if ( dd > 0 ) {
                divisor = gcd(numerator, denominator)
                if ( Math.abs(degree(divisor[0])) > 0 || divisor[0][0] !== rat(1) ) {
                    numerator = divide(numerator, divisor[0])[0]
                    denominator = divide(denominator, divisor[0])[0]
                }
            } else if ( checkForZero(numerator) === 0 ) {
                numerator = [numerator[0].per(denominator[0])]
                denominator = [rat(1)]
            }
        }

        if (  Math.abs(numerator[0].val()) === 0 ) {
            denominator = [rat(1)]
        }

        intvals = numerator.map(function(o){ return rat.toIntValues(o.val())})
        idx = '['+numerator.join(',')+']/['+denominator.join(',')+']'

        if ( typeof pns[idx] === 'undefined' ) {
            pns[idx] = new polyrat
            pns[idx][0] = numerator
            pns[idx][1] = denominator
        }


        return pns[idx]
    }

    piper.polyrat = polyrat

    if ( typeof module != 'undefined' && module.exports )
        module.exports = piper
    else
        root.factory = piper

}(this)
