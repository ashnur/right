{
  "name": "luma",
  "version": "0.2.1",
  "author": {
    "name": "Hugh FD Jackson",
    "email": "@hughfdjackson"
  },
  "description": "A thin layer of JS OO sugar",
  "main": "luma.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/hughfdjackson/luma.git"
  },
  "readme": "# Luma\n\nJavaScript's native OO utilties don't need much neatening up; but it has some rough edges.  Luma smooths them off; by doing as little as possible.\n\n## Walkthrough\n\n\n#### constructors\n\nThe main rough point that luma cleans up is the making of constructor functions.\n\n```JavaScript\n    \n    // instead of this:\n    var Person = function(name){\n        this.name = name\n    }\n\n    Person.prototype = {\n        greet: function(){\n            return 'hi, I\\'m ' + this.name\n        }\n    }\n\n    var hugh = new Person('hugh')\n\n    // we have:\n    var person = luma.factory({\n        init: function(name){\n            this.name = name\n            return this\n        }\n      , greet: function(){\n            return 'hi, I\\'m ' + this.name\n        }\n    })\n\n    var hugh = person('hugh')\n```\n\nAs with constructor functions, `person.prototype` will be the [[Prototype]] property of objects created.\n\nThere are a number of reasons for this design:\n\n* With the `init` function, any applicable value can be returned; whereas, with the `new` operator, only an object can be (otherwise, the object `new` implicitly creates is returned);\n* Avoids clobbering the namespace through a forgotten `new` in non-strict mode code.\n* no two-stage initialisation required for basic constructor creation.\n\n#### creating single objects\n\nAnother rough edge to JS' OO is Object.create.  Luma neatens it up by replacing property descriptor with object(s) to be mixed in to the created object:\n\n```javascript\n    // instead of:\n    var person = { \n            greet: function(){\n                return 'hi, I\\'m ' + this.name\n            }\n        }\n      , hugh = Object.create(person)\n\n    hugh.name = 'hugh'\n\n    // we have:\n    var person = { \n            greet: function(){\n                return 'hi, I\\'m ' + this.name\n            }\n        }\n      , hugh = luma.create(person, { name: 'hugh' })\n```\n\nYou can mixin *any* number of objects this way.  Let's imagine you want to create a person who also has Backbone's Event mixin:\n\n```javascript\n    var hugh = luma.create(person, Backbone.Events, { name: 'hugh' })\n```\n\n\n## API \n\n### luma.factory\n\n```\n    factory :: (proto) -> function\n```\n\nCreates an informal constructor (one that doesn't require `new`) function from a object (which is used as a prototype).  If the prototype has an `init` method available on it, it will be called with the arguments passed to the constructor function.\n\n### luma.create\n\n```\n    create :: (proto, [source]) -> object\n```\n\nCreates an object, with `proto` as its [[Prototype]] object.  Any source objects will be mixed in to the return object.\n\n\n### luma.extend\n\n```\n    extend :: (destination, source, [extra sources] ) -> object\n```\n\nSame as underscore's extend, it shallow copies all enumerable properties from the source objects to the destination object.  When there's a conflict; the rightmost object's property is preferred.\n\n---\n\n## Getting setup\n\nGet via npm:\n\n```\n    npm install luma\n```\n\nOr include as a regular script in the browser:\n\n```html\n    <!-- after copying luma.js to your server -->\n    <script src=\"/luma.js\"></script>\n```\n\n## License\n\nLuma is under the MIT license.\n",
  "_id": "luma@0.2.1",
  "dist": {
    "shasum": "5da8eb2fe0eb9a46d53303bb48536ea321500035"
  },
  "_from": "luma"
}
