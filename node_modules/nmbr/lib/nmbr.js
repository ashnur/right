void function(root){

    require(__dirname + '/../../sinful/sinful.js')
    luma = require('luma')

    numbers = {}

    function riser(int){
        var a = [], i;
        for(i=0;i<int-1;i++){a[i]=number(0)}
        a[i]=number(1)
        return a
    }

    function isInt(input){
        return typeof input !== 'object' && parseInt(input, 10) == input
    }

    function isNat(input){
        return isInt(input) && parseInt(input, 10) > 0
    }

    function toIntValues(integer){
        if ( integer > 0 ) {
            return [integer + 1, 1]
        } else {
            return [1, Math.abs(integer) + 1]
        }
    }

    function gcd(a, b){
        var t;
        a = Math.abs(a)
        b = Math.abs(b)
        while (b > 0) {
            t = b
            b = a % b
            a = t
        }
        return a
    }

    function hashify(input, input2){
        if ( input2 != null ) {
            input = Rat(input, input2)
            return input.toString.call(input)
        } else if ( isInt(input) ) {
            return input.toString()
        } else if ( input.typeLvl === 0 ) {
            return input.value.toString()
        } else if ( input.typeLvl === 1 ) {
            return (input.values[0] - input.values[1]).toString()
        } else if ( input.typeLvl === 2 ) {
            return input.toString()
        } else {
            throw new Error('unrecognizable input: ' + input)
        }
    }

    function number(input, input2){
       var key;

       if ( input == null ) { throw new Error('missing argument') }

       key = hashify(input, input2)

       if ( typeof numbers[key] === 'undefined' ) {
          if ( input2 != null ) {
             if ( ( input.typeLvl === 0 || input.typeLvl === 1 )
                     &&
                  ( input2.typeLvl === 0 || input2.typeLvl === 1 ) ) {
                numbers[key] = Rat(input, input2)
             } else {
                throw new Error('inconsistent input was given')
             }
          } else if ( isNat(input) ) {
             numbers[key] = Nat(input)
          } else if ( isInt(input) ) {
             numbers[key] = Int(input)
          } else {
              throw new Error('unexpected argument')
          }
       }
       return numbers[key]
    }

    function op(method, input, input2){
       var a, b, c, d;
       if ( input == null || input2 == null ) {
          throw new Error('missing argument')
       }
       if ( input.typeLvl == null ) {
          input = number(input)
       }
       if ( input2.typeLvl == null ) {
          input2 = number(input2)
       }
       if ( input.typeLvl == null || input2.typeLvl == null ) {
          throw new Error('unexpected argument value')
       }
       if ( input.typeLvl !== input2.typeLvl ) {
           if ( input.typeLvl === 2 ) {
                input2 = Rat(input2,number(1),false)
           } else if ( input2.typeLvl === 2 ) {
                input = Rat(input,number(1),false)
           }
       }
       if ( input.typeLvl < 2 && input2.typeLvl < 2 ) {
          if ( typeof input.values === 'undefined' ) {
             input.values = toIntValues(input.value)
          }
          if ( typeof input2.values === 'undefined' ) {
             input2.values = toIntValues(input2.value)
          }
          a = input.values[0]
          b = input.values[1]
          c = input2.values[0]
          d = input2.values[1]
          if ( method === 'plus' ) {
             return number((a + c) - (b + d))
          } else if ( method === 'minus' ) {
             return number((a + d) - (b + c))
          } else if ( method === 'times' ) {
             return number((a * c + b * d) - (a * d + b * c))
          } else if ( method === 'per' ) {
             return number(input, input2)
          } else {
             throw new Error('unrecognized operation')
          }
       } else if ( input.typeLvl === 2 && input2.typeLvl === 2 ) {
          if ( input.typeLvl === 0 ) {
             a = input.value
             b = 1
          } else if ( input.typeLvl === 1 ) {
             a = input.values[0] - input.values[1]
             b = 1
          } else if ( input.typeLvl === 2 ) {
             a = input.numerator
             b = input.denominator
          }
          if ( input2.typeLvl === 0 ) {
             c = input2.value
             d = 1
          } else if ( input2.typeLvl === 1 ) {
             c = input2.values[0] - input2.values[1]
             d = 1
          } else if ( input2.typeLvl === 2 ) {
             c = input2.numerator
             d = input2.denominator
          }

          if ( typeof a.value !== 'undefined' ) {
             a = a.value
          }
          if ( typeof b.value !== 'undefined' ) {
             b = b.value
          }
          if ( typeof c.value !== 'undefined' ) {
             c = c.value
          }
          if ( typeof d.value !== 'undefined' ) {
             d = d.value
          }
          if ( method === 'plus' ) {
             return number(number(a * d + b * c), number(b * d))
          } else if ( method === 'times' ) {
             return number(number(a * c), number(b * d))
          } else if ( method === 'minus' ) {
             return number(number(a * d - b * c), number(b * d))
          } else if ( method === 'per' ) {
             return number(number(a * d), number(b * c))
          } else if ( method === 'per' ) {
             return number(number(a * d), number(b * c))
          }
          throw new Error('undefined operation on Rat')
       } else {
           console.log('unknown operation:',method,input,input2)
           throw new Error('unknown operation')
       }
    }


    var Nat = luma.factory({
        init : function(input){
            var n;
            n = parseInt(input, 10)
            if ( isNat(n) ) {
                this.value = n
                return this
            } else {
                throw new Error('expecting natural, unexpected:' + input + ' given')
            }
        }
        , value : null
        , typeLvl : 0
        , plus : function(input){
            return op('plus', this, input)
        }
        , times : function(input){
            return op('times', this, input)
        }
        , minus : function(input){
            return op('minus', this, input)
        }
        , per : function(input){
            return op('per', this, input)
        }
        , toString : function(){
            return hashify(this)
        }
    })

    var Int = luma.factory({
        init : function(input){
            var n, values;
            n = parseInt(input, 10)
            if ( isInt(n) ) {
                values = toIntValues(n)
            } else {
                throw new Error('expecting integer, unexpected:' + input + ' given')
            }
            this.value = values[0] - values[1]
            this.values = values
            return this
        }
        , value : null
        , values : null
        , typeLvl : 1
        , plus : function(input){
          return op('plus', this, input)
        }
        , times : function(input){
            return op('times', this, input)
        }
        , minus : function(input){
            return op('minus', this, input)
        }
        , per : function(input){
            return op('per', this, input)
        }
        , toString : function(){
            return hashify(this)
        }
    })

    var Rat = luma.factory({
        init : function(n, d, s){
            var denominator, divisor, inv, numerator;
            if ( n.typeLvl === 0 || n.typeLvl === 1 ) {
                numerator = n
            } else {
                throw new Error('unexpected numerator value given')
            }
            if ( d.typeLvl === 0 || d.typeLvl === 1 ) {
                denominator = d
            } else {
                throw new Error('unexpected denominator value given')
            }
            if ( typeof s === 'undefined' ) {
                s = true
            }
            if ( s ) {
                divisor = gcd(numerator.value, denominator.value)
                if ( divisor > 1 ) {
                    numerator = number(numerator.value / divisor)
                    denominator = number(denominator.value / divisor)
                }
                if ( denominator.typeLvl === 1 ) {
                    inv = number(-1)
                    numerator = numerator.times(inv)
                    denominator = denominator.times(inv)
                }
                if ( denominator.value === 1 ) {
                    return number(numerator)
                }
                if ( denominator.value === -1 ) {
                    return number(numerator).times(inv)
                }
            }
            if ( denominator.value === 0 ) {
                throw new Error("rationals with denominator = 0 are not defined")
            }
            this.numerator = numerator
            this.denominator = denominator
            return this
        }

        , typeLvl : 2

        , toString : function(){
            return this.numerator.value + '/' + this.denominator.value
        }
        , aprox : function(){
            return this.numerator / this.denominator
        }
        , plus : function(input){
            return op('plus', this, input)
        }
        , times : function(input){
            return op('times', this, input)
        }
        , minus : function(input){
            return op('minus', this, input)
        }
        , per : function(input){
            return op('per', this, input)
        }
    })


    // export
    if ( typeof module != 'undefined' && module.exports )
        module.exports = number
    else
        root.factory = number
}(this)
