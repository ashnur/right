void function(root){

    require(__dirname + '/../../sinful/sinful.js')
    num = require('nmbr')
    luma = require('luma')
    spce = require('spce')

    var plumber, create, factory, init, luma, num,ZERO,ONE,TWO, pns = [];
    ZERO = num(0)
    ONE = num(1)
    TWO = num(2)

    function riser(int){
        var a = [], i;
        for(i=0;i<int-1;i++){a[i]=ZERO}
        a[i]=ONE
        return a
    }
    function m(base, exp){
        var ret;
        if(base.typeLvl<2){
            ret = num(Math.pow(base.value, exp.value))
            return ret
        }else{
            ret = num(num(Math.pow(base.numerator, exp.value)),num(Math.pow(base.denominator, exp.value)))
            return ret
        }
    }

    function evaluate(x,i){ value = value.plus(x.times(pow(input,i))) }


    var PolyNat = luma.factory({
        init: function(input) {
            var n;
            if(Array.isArray(input)){
                this.ixs = input.map(function(x){return num(x)})
            }else{
                this.ixs = [num(input)]
            }
            this.degree = this.ixs.length - 1
            return this
        }
        , ixs : []
        , typeLvl : 3
        , degree: 0
        , plus : function(input) {
            if (typeof input == 'undefined') throw new Error('argument required')
            if (typeof input.typeLvl == 'undefined') input = num(input)
            if (input.typeLvl < 3 ) input = plumber(input)
            var len = this.ixs.length > input.ixs.length ? this.ixs.length : input.ixs.length
                , i, l, r , result = [];
            for ( i = 0; i < len; i++ ) {
                l = typeof this.ixs[i] !== 'undefined' ? this.ixs[i] : ZERO
                r = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : ZERO
                result[i] = l.plus(r)
            }
            return plumber(result)
        }
        , minus : function(input) {
            if (typeof input == 'undefined') throw new Error('argument required')
            if (typeof input.typeLvl == 'undefined') input = num(input)
            if (input.typeLvl < 3 ) input = plumber(input)
            var len = this.ixs.length > input.ixs.length ? this.ixs.length : input.ixs.length
                , i, l, r , result = [];
            for ( i = 0; i < len; i++ ) {
                l = typeof this.ixs[i] !== 'undefined' ? this.ixs[i] : ZERO
                r = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : ZERO
                result[i] = l.minus(r)
            }
            return plumber(result)
        }
        , times : function(input) {
            if (typeof input == 'undefined') throw new Error('argument required')
            if (typeof input.typeLvl == 'undefined') input = num(input)
            if (input.typeLvl < 3 ) input = plumber(input)
            var p = this.ixs, q = input.ixs , result = [] , i, j;
            for ( i=0; i<p.length; i++ ){
                for ( j=0; j<q.length; j++ ){
                    if ( typeof result[i+j] === 'undefined' ) result[i+j] = ZERO
                    result[i+j] = result[i+j].plus(p[i].times(q[j]))
                }
            }
            return plumber(result)
        }
        , per : function(input) {
            return op('per', this, input)
        }
        , toString: function () { return '['+this.ixs.join(',')+']' }
        , pow : function (exp){
            var ret;
            if(typeof exp == 'undefined') throw new Error('argument required')
            if(typeof exp.typeLvl == 'undefined') exp = num(exp)
            if(exp.typeLvl > 2) throw new Error('undefined operation, look for roots elsewhere')
            if (this.degree === 0) {
                ret = m(this.ixs[0], exp)
            } else {
                this.ixs.forEach(evaluate)
                throw 'dunno'
            }

            return ret
        }
        , val: function(input) {
            var value = ZERO, i, len;
            if ( input == null ) throw new Error('missing argument')
            if ( input.typeLvl == null || input.typeLvl < 3 ) input = plumber(input)
            len = this.ixs.length
            for ( i=0; i < len; i++ ) {
                value = value.plus(this.ixs[i].times(input.pow(i)))
            }
            return value
        }
    })

    function hashify ( input ) {
        if ( Array.isArray(input) ) {
            return '['+input.map(function(x){return num(x)}).join(',')+']'
        } else {
            return '['+num(input)+']'
        }
    }

    function plumber(input){
        if (input == null) { throw new Error('missing argument') }

        key = hashify(input)

        if  ( typeof pns[key] === 'undefined' ) {
            pns[key] = PolyNat(input)
        }

        return pns[key]
    }


    // export
    if ( typeof module != 'undefined' && module.exports )
        module.exports = plumber
    else
        root.factory = plumber

}(this)
