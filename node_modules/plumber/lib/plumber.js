require(__dirname + '/../../sinful/sinful.js')
void function(root){

    var luma, num, pns = [];

    num = require('nmbr')
    luma = require('luma')
    spce = require('spce')

    function gcd(p, q){
        var f = p, g = q,s, t;
        debugger
        while ( f.degree > 0 && g.degree > 0 )  {
            console.log('f',f.degree,f+'')
            console.log('g',g.degree,g+'')
            t = g
            s = divide(f, g)
            g = s[1]
            if ( typeof g.degree === 'undefined' ) return t
            f = t
        }

        return plumber(1)
    }

    function divide(p, q){
        var n, u, v, k, j, s=[], r=[];
        u = p.ixs.slice(0)
        v = q.ixs.slice(0)
        for ( k = p.degree - q.degree ; k >= 0 ; k-- ) {
            s[k] = u[q.degree+k].per(v[q.degree])
            for ( j = q.degree + k  ; j >= k ; j-- ) {
                u[j] = u[j].minus(s[k].times(v[j-k]))
            }
        }
        if ( s.length === 0 ) s = [0]
        if ( u.length === 0 ) u = [0]
        return [plumber(s),plumber(u)]
    }

    function rtrim(arr){
        while ( arr.length > 1 && arr[arr.length-1] === num(0)  ) {
            arr.pop()
        }
        return arr
    }

    function riser(to){
        var a = [], i;
        for ( i=0; i<to-1; i++ ){ a[i] = num(0) }
        a[i] = num(1)
        return a
    }

    function m(base, exp){
        var ret;
        if( base.typeLvl < 2 ){
            ret = num(Math.pow(base.value, exp.value))
            return ret
        }else if ( base.typeLvl === 2 ){
            ret = num(num(Math.pow(base.numerator, exp.value)),num(Math.pow(base.denominator, exp.value)))
            return ret
        } else {
            throw new Error('unexpected argument')
        }
    }

    function hashify(input, input2) {
        var ret;
        if ( input2 != null ) {
            ret = PolyRat(input, input2).toString()
            return ret
        } else if ( Array.isArray(input) ) {
            ret = input.map(function(x){return num(x)})
            ret = rtrim(ret)
            return '['+ret.join(',')+']'
        } else if ( typeof input === 'object' && input.typeLvl > 2 ) {
            ret = input.toString()
            return ret
        } else {
            return '['+num(input)+']'
        }
    }

    function plumber(input, input2){
        var key;
        if ( input == null ) { throw new Error('missing argument') }

        key = hashify(input, input2)

        if  ( typeof pns[key] === 'undefined' ) {
            if ( input2 != null ) {
                pns[key] = PolyRat(input, input2)
            } else {
                pns[key] = PolyInt(input)
            }
        }

        return pns[key]
    }

    function op(method, input, input2){

        var len, result = [], i, j, l, len, r, p, plen, q, qlen;

        if ( input == null || input2 == null ) {
            console.log( input, input2 )
            throw new Error('missing argument')
        }

        if ( input.typeLvl == null || input.typeLvl < 3) {
           input = plumber(input)
        }

        if ( input2.typeLvl == null || input2.typeLvl < 3) {
           input2 = plumber(input2)
        }

        if ( input.typeLvl == null || input2.typeLvl == null ) {
           throw new Error('unexpected argument value')
        }

        if ( input.typeLvl !== input2.typeLvl ) {
            if ( input.typeLvl === 5 ) {
                 input2 = PolyRat(input2, plumber(1), false)
            } else if ( input2.typeLvl === 5 ) {
                 input = PolyRat(input, plumber(1), false)
            }
            return input[method](input2)
        }

        if ( method === 'plus' ) {
            if ( input.ixs.length > input2.ixs.length ) {
                len = input.ixs.length
            } else {
                len = input2.ixs.length
            }
            for ( i = 0; i < len; i++ ) {
                l = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : num(0)
                r = typeof input2.ixs[i] !== 'undefined' ? input2.ixs[i] : num(0)
                result[i] = l.plus(r)
            }
        } else if ( method === 'minus' ) {
            if ( input.ixs.length > input2.ixs.length ) {
                len = input.ixs.length
            } else {
                len = input2.ixs.length
            }
            for ( i = 0; i < len; i++ ) {
                l = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : num(0)
                r = typeof input2.ixs[i] !== 'undefined' ? input2.ixs[i] : num(0)
                result[i] = l.minus(r)
            }
        } else if ( method === 'times' ) {
            p = input.ixs.slice(0)
            plen = input.ixs.length
            q = input2.ixs.slice(0)
            qlen = input2.ixs.length
            for ( i=0; i<plen; i++ ){
                for ( j=0; j<qlen; j++ ){
                    if ( typeof result[i+j] === 'undefined' ) result[i+j] = num(0)
                    if ( typeof p[i+j] === 'undefined' ) p[i+j] = num(0)
                    if ( typeof q[i+j] === 'undefined' ) q[i+j] = num(0)

                    result[i+j] = result[i+j].plus(p[i].times(q[j]))
                }
            }
        } else if ( method === 'pow' ) {
            if ( input2.typeLvl > 1 ) {
                if ( typeof input2.ixs !== 'undefined'
                        && input2.ixs.length === 1 ) {
                    input2 = input2.ixs[0]
                } else {
                    throw new Error('undefined operation, look for roots elsewhere')
                }
            }

            i=0
            len=input2.value
            result = input
            if ( input2 !== num(0) ) {
                while ( ++i < len ) {
                    result = result.times(input)
                }
            } else {
                result = plumber(1)
            }
        } else if ( method === 'val' ) {
            result = plumber(0)
            len = input.ixs.length;
            if ( input2.typeLvl == null || input2.typeLvl < 3 ) input = plumber(input2)
            for ( i=0; i < len; i++ ) {
                result = result.plus(plumber(input.ixs[i]).times(input2.pow(i)))
            }
        } else if ( method === 'compose' ) {
        } else if ( method === 'gt' ) {
            return true
        } else if ( method === 'per' ) {
            if ( input.typeLvl === 5 && input2.typeLvl === 5 ) {
                result = divide(input, input2)
            } else {
                result = plumber(input, input2)
            }
        } else {
            throw new Error('undefined operation: '+method)
        }

        return plumber(result)

    }

    var PolyInt = luma.factory({
        init: function(input) {
            var n;
            if ( Array.isArray(input) ){
                this.ixs = input.map(function(x){return num(x)})
                this.ixs = rtrim(this.ixs)
            } else {
                this.ixs = [num(input)]
            }
            if ( this.ixs.length === 0 || (this.ixs.length === 1 && this.ixs[0] === num(0) ) ) {
                this.degree = Math.MIN_VALUE
            } else {
                this.degree = this.ixs.length - 1
            }
            return this
        }
        , ixs : []
        , typeLvl : 4
        , degree: 0
        , toString: function(){ return '['+this.ixs.join(',')+']' }
        , plus : function(input){
            return op('plus',this,input)
        }
        , minus : function(input){
            return op('minus',this,input)
        }
        , times : function(input){
            return op('times',this,input)
        }
        , pow : function (input){
            return op('pow',this,input)
        }
        , val : function (input){
            return op('val',this,input)
        }
        , compose : function (input){
            return op('compose',this,input)
        }
        , per : function (input){
            return op('per',this,input)
        }
        , divide : function (input){
            return divide(this,input)
        }
        , gcd : function (input){
            return gcd(this,input)
        }
        , gt : function (input){
            return op('gt',this,input)
        }
    })

    var PolyRat = luma.factory({
        init: function(input,input2,s) {
            var denominator=plumber(input2), numerator=plumber(input), divisor
                , inv, n, t;
            if ( input.typeLvl < 3 || input.typeLvl > 5
                || input2.typeLvl < 3 || input.typeLvl > 5 ){
                    throw new Error('dafuq')
            }
            if ( typeof s === 'undefined' ) {
                s = true
            }
            if ( s ) {
                divisor = gcd(numerator, denominator)
                if ( divisor !== plumber(1) ) {
                    t = divide(numerator,divisor)
                    numerator = t[0]
                    t = divide(denominator,divisor)
                    denominator = t[0]
                }
                if ( denominator === plumber(1) ) {
                    return numerator
                }
            }
            this.numerator = numerator
            this.denominator = denominator
            if ( numerator.degree > denominator.degree ) {
                this.degree =  numerator.degree
            } else {
                this.degree =  denominator.degree
            }
            return this
        }
        , numerator : null
        , denominator : null
        , typeLvl : 5
        , degree: 0
        , toString: function () { return '['+this.numerator.toString()+','+this.denominator.toString()+']' }
        , plus : function(input) {
            var p = this.numerator
                , q = this.denominator
                , r = input.numerator
                , s = input.denominator
                ;
            return p.times(s).plus(r.times(q)).per(q.times(s))
        }
        , times : function(input) {
            var p = this.numerator
                , q = this.denominator
                , r = input.numerator
                , s = input.denominator
                ;
            return p.times(r).per(q.times(s))
        }
        , minus : function(input) {
            var p = this.numerator
                , q = this.denominator
                , r = input.numerator
                , s = input.denominator
                , t, t1, t2
                ;
            debugger
            t = q.times(s)
            t1 = p.times(s)
            t2 = r.times(q)
            return (t1.minus(t2)).per(t)
        }
        , pow : function (input){
            return op('pow',this,input)
        }
        , val : function (input){
            return op('val',this,input)
        }
        , compose : function (input){
            return op('compose',this,input)
        }
        , per : function (input){
            var p = this.numerator
                , q = this.denominator
                , r = input.numerator
                , s = input.denominator
                ;
            return p.times(s).per(r.times(q))
        }
        , divide : function (input){
            return divide(this,input)
        }
        , gcd : function (input){
            return gcd(this,input)
        }
        , gt : function (input){
            return op('gt',this,input)
        }
    })



    // export
    if ( typeof module != 'undefined' && module.exports )
        module.exports = plumber
    else
        root.factory = plumber

}(this)
