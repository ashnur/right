require(__dirname + '/../../sinful/sinful.js')
void function(root){

    var luma, num, pns = [];

    num = require('nmbr')
    luma = require('luma')
    spce = require('spce')

    function rtrim(arr){
        while ( arr.length > 1 && arr[arr.length-1] === num(0)  ) {
            arr.pop()
        }
        return arr
    }

    function riser(to){
        var a = [], i;
        for ( i=0; i<to-1; i++ ){ a[i] = num(0) }
        a[i] = num(1)
        return a
    }

    function m(base, exp){
        var ret;
        if( base.typeLvl < 2 ){
            ret = num(Math.pow(base.value, exp.value))
            return ret
        }else if ( base.typeLvl === 2 ){
            ret = num(num(Math.pow(base.numerator, exp.value)),num(Math.pow(base.denominator, exp.value)))
            return ret
        } else {
            throw new Error('unexpected argument')
        }
    }

    function hashify(input) {
        var ret;
        if ( Array.isArray(input) ) {
            ret = input.map(function(x){return num(x)})
            ret = rtrim(ret)
            return '['+ret.join(',')+']'
        } else if ( typeof input === 'object' && input.typeLvl > 2 ) {
            ret = input.toString()
            return ret
        } else {
            return '['+num(input)+']'
        }
    }

    function plumber(input){
        var key;
        if (input == null) { throw new Error('missing argument') }

        key = hashify(input)

        if  ( typeof pns[key] === 'undefined' ) {
            pns[key] = PolyInt(input)
        }

        return pns[key]
    }

    function op(method, input, input2){

        var len, result = [], i, j, l, len, r, p, plen, q, qlen;

        if ( input == null || input2 == null ) {
            throw new Error('missing argument')
        }

        if ( input.typeLvl == null || input.typeLvl < 3) {
           input = plumber(input)
        }

        if ( input2.typeLvl == null || input2.typeLvl < 3) {
           input2 = plumber(input2)
        }

        if ( input.typeLvl == null || input2.typeLvl == null ) {
           throw new Error('unexpected argument value')
        }

        if ( input.typeLvl !== input2.typeLvl ) {
            if ( input.typeLvl === 5 ) {
                 input2 = PolyRat(input2, plumber(1), false)
            } else if ( input2.typeLvl === 5 ) {
                 input = PolyRat(input, plumber(1), false)
            }
        }

        if ( method === 'plus' ) {
            if ( input.ixs.length > input2.ixs.length ) {
                len = input.ixs.length
            } else {
                len = input2.ixs.length
            }
            for ( i = 0; i < len; i++ ) {
                l = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : num(0)
                r = typeof input2.ixs[i] !== 'undefined' ? input2.ixs[i] : num(0)
                result[i] = l.plus(r)
            }
        } else if ( method === 'minus' ) {
            if ( input.ixs.length > input2.ixs.length ) {
                len = input.ixs.length
            } else {
                len = input2.ixs.length
            }
            for ( i = 0; i < len; i++ ) {
                l = typeof input.ixs[i] !== 'undefined' ? input.ixs[i] : num(0)
                r = typeof input2.ixs[i] !== 'undefined' ? input2.ixs[i] : num(0)
                result[i] = l.minus(r)
            }
        } else if ( method === 'times' ) {
            p = input.ixs.slice(0)
            plen = input.ixs.length
            q = input2.ixs.slice(0)
            qlen = input2.ixs.length
            for ( i=0; i<plen; i++ ){
                for ( j=0; j<qlen; j++ ){
                    if ( typeof result[i+j] === 'undefined' ) result[i+j] = num(0)
                    if ( typeof p[i+j] === 'undefined' ) p[i+j] = num(0)
                    if ( typeof q[i+j] === 'undefined' ) q[i+j] = num(0)

                    result[i+j] = result[i+j].plus(p[i].times(q[j]))
                }
            }
        } else if ( method === 'pow' ) {
            if ( input2.typeLvl > 1 ) {
                if ( typeof input2.ixs !== 'undefined'
                        && input2.ixs.length === 1 ) {
                    input2 = input2.ixs[0]
                } else {
                    throw new Error('undefined operation, look for roots elsewhere')
                }
            }

            i=0
            len=input2.value
            result = input
            if ( input2 !== num(0) ) {
                while ( ++i < len ) {
                    result = result.times(input)
                }
            } else {
                result = plumber(1)
            }
        } else if ( method === 'val' ) {
            result = plumber(0)
            len = input.ixs.length;
            if ( input2.typeLvl == null || input2.typeLvl < 3 ) input = plumber(input2)
            for ( i=0; i < len; i++ ) {
                result = result.plus(plumber(input.ixs[i]).times(input2.pow(i)))
            }
        } else if ( method === 'compose' ) {
        } else if ( method === 'per' ) {

        } else {
            throw new Error('undefined operation: '+method)
        }

        return plumber(result)

    }

    var PolyInt = luma.factory({
        init: function(input) {
            var n;
            if ( Array.isArray(input) ){
                this.ixs = input.map(function(x){return num(x)})
                this.ixs = rtrim(this.ixs)
            } else {
                this.ixs = [num(input)]
            }
            this.degree = this.ixs.length - 1
            return this
        }
        , ixs : []
        , typeLvl : 4
        , degree: 0
        , toString: function () { return '['+this.ixs.join(',')+']' }
        , plus : function(input) {
            return op('plus',this,input)
        }
        , minus : function(input) {
            return op('minus',this,input)
        }
        , times : function(input) {
            return op('times',this,input)
        }
        , pow : function (input){
            return op('pow',this,input)
        }
        , val : function (input){
            return op('val',this,input)
        }
        , compose : function (input){
            return op('compose',this,input)
        }
        , per : function (input){
            return op('per',this,input)
        }
    })



    // export
    if ( typeof module != 'undefined' && module.exports )
        module.exports = plumber
    else
        root.factory = plumber

}(this)
