void function(root){
    "use strict"

    var piper = require('piper')
        , ONE, ZERO
        , defaults = {}
        , spce = require('spce')
        , sybs = {}
        , tkns = []
        , rat = require('rats')
        ;

//    piper.polyrat.prototype.toString = function(){
//        var pretty = function(c){return c[0]+(c[1]?'':'/'+c[1])}
//            , r
//            ;
//        if ( this[1].length = 1 && this[1][0] == piper([1]) ) {
//            r = '(['+this[0].map(pretty).join(',')+'])'
//        } else {
//            r = '(['+this[0].map(pretty).join(',')+']/['+this[1].map(pretty).join(',')+'])'
//        }
//        return r
//    }

    function tokenize(input){
        return tknzr.call(input)
    }

    function tknzr(){

        if ( typeof this === "undefined" ||  this === null ) {
            return
        }

        var c, from, i=0
            , length, n
            , result = []
            , str = '', _ref
            ;

        length = this.length

        function make(type, value){
            return {
                type: type,
                value: value,
                from: from,
                to: i,
                toString: function(){
                    return value.toString()
                }
            }
        }

        c = this.charAt(i)

        while ( c ) {
            from = i
            if ( c === ' ' ) {
                i += 1
                c = this.charAt(i)
            } else if ( /[a-zA-Z]/.test(c) ) {
                str = c
                i += 1
                while ( true ) {
                    c = this.charAt(i)
                    if ( /[0-9a-zA-Z]/.test(c) ) {
                        str += c
                        i += 1
                    } else {
                        break
                    }
                }
                result.push(make('var', str))
            } else if ( /[0-9]/.test(c) ) {
                str = c
                i += 1
                while ( true ) {
                    c = this.charAt(i)
                    if ( !/[0-9]/.test(c) ) {
                        break
                    }
                    i += 1
                    str += c
                }
                if ( /[a-zA-Z]/.test(c) ) {
                    str += c
                    i += 1
                    throw 'Bad number'
                }
                n = parseInt(str, 10)
                if ( isFinite(n) ) {
                    result.push(make('number', n))
                } else {
                    throw 'Bad number'
                }
            } else {
                i += 1
                result.push(make('operator', c))
                c = this.charAt(i)
            }
        }
        return result
    }

    function sybl(token, lvl){
        var x
            ;
        if ( lvl == null ) {
            lvl = 1
        }
        this.lvl = lvl
        this.toString = token.toString
        x = extend(token, this)
        return x
    }

    function variable(name){
        return spce.push(name)
    }

    function symblzr(token, lvl, slv){
        var s, type, value;
        s = this[token.toString()]
        if ( s == null ) {
            s = new sybl(token, lvl)
            value = s != null ? s.toString() : void 0
            type = s != null ? s.type : void 0
            if ( type === 'var' ) {
                s = piper([0,1])
                s.lvl = 1
            } else if ( type === 'operator' ) {
                s.slv = (slv != null) ? slv : (function() {
                    console.error(this)
                    throw new Error('undefined operator')
                })
            } else if ( type === 'number' ) {
                s = piper([value])
                s.lvl = 1
            }
            this[token.toString()] = s
        }
        return s
    }

    function ct(str){
        var t
            ;
        t = tokenize(str)
        if ( str.length < 2 ) {
            return t[0]
        } else {
            return t
        }
    }

    function literal(tok){
        var ctok, r
            ;
        if ( typeof tok === 'string' ) {
            ctok = ct(tok)
        } else {
            ctok = tok
        }
        r = symblzr.call(sybs, ctok, 1, (function(right){
            return right
        }))
        return r
    }

    ZERO = literal("0")

    ONE = literal("1")

    symblzr.call(defaults, ct("\n"), -1, (function(l, r){
        if ( l == null ) {
            l = ZERO
        }
        return literal(l)
    }))

    symblzr.call(defaults, ct("+"), 2, (function(l, r){
        if ( l == null ) {
            l = ZERO
        }
        if ( r == null ) {
            r = ZERO
        }
        return literal(l.plus(r))
    }))

    symblzr.call(defaults, ct("-"), 2, (function(l, r){
        var x
            ;
        if ( l == null ) {
            l = ZERO
        }
        if ( r == null ) {
            r = ZERO
        }
        x = literal(l.minus(r))
        return x
    }))

    symblzr.call(defaults, ct("*"), 3, (function(l, r){
        if ( l == null ) {
            l = ONE
        }
        if ( r == null ) {
            r = ONE
        }
        return literal(l.times(r))
    }))

    symblzr.call(defaults, ct("/"), 3, (function(l, r){
        if ( l == null ) {
            l = ONE
        }
        if ( r == null ) {
            r = ONE
        }
        return literal(l.per(r))
    }))

    symblzr.call(defaults, ct("^"), 4, (function(l, r){
        if ( l == null ) {
            l = ONE
        }
        if ( r == null ) {
            r = ZERO
        }
        //this is freakingly ugly
        return literal(piper([l.pow(r[0][0][0])]))
    }))

    symblzr.call(defaults, ct(")"), 0, (function(l){
        return literal(l)
    }))

    symblzr.call(defaults, ct("("), 10, (function(l,r){
        var e = expr(0)
            ;
        tkns.shift()
        return e
    }))

    symblzr.call(defaults, ct("="), 11, (function(l,r){
        if ( l == null || r == null ) throw new Error ('equations have two sides' )
        return null
    }))

    function symbolize(tokens){
        var token, i, len
            ;
        sybs = extend({}, defaults)
        for ( i = 0, len = tokens.length; i < len; i++ ) {
            token = tokens[i]
            symblzr.call(sybs, token)
        }
        return sybs
    }

    function extend(obj){
        Array.prototype.forEach.call(Array.prototype.slice.call(arguments, 1), function(source){
            var prop
                ;
            for ( prop in source ) {
                obj[prop] = source[prop]
            }
        })
        return obj
    }
    function w(i){
        var key =  (tkns[i] != null) ? tkns[i].toString() : void 0
            ;
        return sybs[key]
    }

    function c(i){
        var key = tkns.splice(i, 1, null)[0]
            ;
        return sybs[key]
    }

    function x(i){
        var key = tkns.splice(i, 1)[0]
            ;
        if ( key instanceof Int32Array ) {
            return key
        }
        return sybs[key]
    }

    function g(i, o){
        return tkns.splice(i, 1, o)
    }

    function t(i){
        var _ref
            ;
        return (_ref = w(i)) != null ? _ref.type : void 0
    }

    function v(i){
        var ref = w(i), ref1 = ref != null ? ref.lvl : void 0
            ;
        return ref1 != null ? ref1 : Number.MIN_VALUE
    }

    function isop(i){
        return t(i) === 'operator'
    }

    function unry(i){
        var operator, rhs, lhs = null, ret, paren = false
            ;
        operator = c(i)
        if ( operator.lvl === 10 ) {
            if ( i === 1 ) lhs = tkns.shift()
            tkns.shift()
            rhs = null
            paren = true
        } else if ( v(i+1) === 10 ) {
            if ( i === 1 ) lhs = tkns.shift()
            tkns.shift()
            rhs = expr(0)
            tkns.shift()
            paren = true
        } else if ( ! isop(i + 1) ) {
            rhs = x(i + 1)
        } else {
            rhs = null
        }
        if ( paren ) {
            ret = tkns.splice(0, 0, operator.slv(null, rhs))
            if ( lhs !== null ) tkns.splice(0, 0, lhs)
        } else {
            ret = g(i, operator.slv(null, rhs))
        }
        return ret
    }

    function expr(lvl){
        var l = isop(0) ? null : x(0), nextop, operator, r
            ;

        while ( isop(0) && v(0) > lvl ) {
            while ( isop(1) && v(0) !== 10 && v(1) !== 10 ) {
                unry(1)
                if ( l == null ) {
                    unry(0)
                    l = x(0)
                }
            }
            if ( isop(0) ) {
                operator = x(0)
                if ( operator.lvl !== 10 ) {
                    r = !isop(0) ? w(0) : null
                    nextop = r != null ? 1 : 0
                }
                if ( v(nextop) <= operator.lvl ) {
                    if (r != null) {
                        x(0)
                    }
                } else {
                    r = expr(operator.lvl)
                }
                l = operator.slv(l, r)
            }
        }
        return l
    }

    function parse(input){
        var counter, e
            ;
        tkns = tokenize(input)
        sybs = symbolize(tkns)
        spce.del('input')
        counter = 0
        while ( tkns.length > 0 ) {
            e = expr(-1)
            spce.push('input', e)
            if ( typeof tkns[0] !== 'undefined'
                && typeof sybs[tkns[0].value] !== 'undefined'
                && sybs[tkns[0].value].lvl === -1 ) {
                    tkns.shift()
            }
            if (++counter > 100) {
                throw new Error('possible infinite loop')
            }
        }
        return spce.get('input')
    }
    if ( typeof module != 'undefined' && module.exports ) {
        module.exports = parse
    } else {
        root.factory = parse
    }

}(this)
