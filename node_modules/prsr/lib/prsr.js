void function(root){
    "use strict"

    var tokenizer = require('./tokenizer.js')
        , symbol_table = {}
        , variables = {}
        , token
        , tokens
        , token_nr
        , polyrat = require('polyrats')
        , ZERO =  polyrat([0])
        , ONE =  polyrat([1])
        , NEGONE =  polyrat([-1])
        ;

    tokenizer.add_type('variable', function(source, i){
        var c = source.charAt(i)
            , lead = /[a-zA-Z]/
            , follow = /[a-zA-Z0-9_]/
            , str = ''
            ;

        function forward(){
            str += c
            i ++
        }

        if ( lead.test(c) ) {
            forward()
            while ( true ) {
                c = source.charAt(i);
                if ( follow.test(c) ) {
                    forward()
                } else {
                    break
                }
            }
            if ( str.length > 1 ) throw new Error('wtf')
            variables[str] = polyrat([0,1])
            return {value: str, to: i}
        }
        return false
    })

    tokenizer.add_type('number', function(source, i){
        var c = source.charAt(i)
            , digits = /[0-9]/
            , letters = /[a-zA-Z]/
            , str = ''
            , n = 0
            ;

        function forward(){
            str += c
            i ++
        }

        if ( digits.test(c) ) {
            forward()
            while ( true ) {
                c = source.charAt(i);
                if ( digits.test(c) ) {
                    forward()
                } else {
                    break
                }
            }
            n = Number(str)
            if ( ! isFinite(n) ) {
                throw new Error('Bad number')
            }
            return {value: n, to: i}
        }
        return false
    })

    tokenizer.add_type('operator', function(source, i){
        var c = source.charAt(i)
            , not_alphanumeric = /[^0-9a-zA-Z]/
            ;
        i++
        return not_alphanumeric.test(c) ? {value: c, to: i } : false

    })

    var original_symbol = {
        nud: function () { throw new Error("Undefined. " + this.id) }
        , led: function (left) { throw new Error("Missing operator. " + this.id) }
    }


    function itself(){ return this }

    function symbol(id, bp){
        var s = symbol_table[id]
            ;
        bp = bp || 0
        if (s) {
            if (bp >= s.lbp) { s.lbp = bp }
        } else {
            s = Object.create(original_symbol)
            s.id = s.value = id
            s.lbp = bp
            symbol_table[id] = s
        }
        return s
    }

    function infix(id, bp, led){
        var s = symbol(id, bp);
        s.led = led || function (left) {
            return expression(bp)
        }
        return s
    }

    function prefix(id, nud){
        var s = symbol(id);
        s.nud = nud || function(){
            return expression(10)
        }
        return s
    }

    function both(id, bp, nud, led){
        var s = symbol(id, bp);
        s.nud = nud || function(){
            return expression(10)
        }
        s.led = led || function (left) {
            return expression(bp)
        }
        return s
    }

    function statement(s, f){
        var x = symbol(s)
        x.std = f
        return x
    }

    function create_token(){
        var token
            , v
            , t
            , arity
            , object
            ;

        t = tokens[token_nr]
        if ( t === undefined ) return
        v = t.value
        arity = t.type
        if (arity ===  "number") {
            token = polyrat([t.value])
            token.nud = itself
        } else if (arity === "variable") {
            token = variables[v]
            token.name = v
            token.nud = itself
        } else {
            if (arity === "operator") {
                object = symbol_table[v]
                if (!object) { throw new Error("Unknown operator. "+v) }
            } else {
                throw new Error("Unexpected token. "+arity)
            }
            token = Object.create(object)
            token.from  = t.from
            token.to    = t.to
            token.value = v
            token.arity = arity
            token.nr = token_nr
        }
        return token
    }

    function advance(id){

        if (id && token.id !== id) { throw new Error("Expected '" + id + "'.") }
        token = create_token()
        token_nr++

    }

    function expression(rbp){
        var left
            , t = token
            ;
        if ( t === undefined ) return
        if (t.std) {
            advance()
            return t.std()
        }
        advance()
        left = t.nud()
        while ( token && token.lbp > rbp ) {
            t = token
            advance()
            left = t.led(left)
        }
        return left
    }

    function parse(source){
        var a = []
            , s
            ;
        a.toString = function(){
            return this.join('\n')
        }
        token_nr = 0
        tokens = tokenizer(source)
        advance()
        while ( token ) {
            s = expression(0)
            if ( s ) {
                 a.push(s)
            } else if ( s === undefined ) {
                break
            }
        }
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
    }

    symbol("(end)")
    symbol("(variable)").nud = itself
    symbol("(literal)").nud = itself
    both("+", 3, function(){
        var right = expression(3);
        return right == null ? ZERO : right
    }, function(left){
        var right = expression(3);
        return (left == null ? ZERO : left).plus((right == null ? ZERO : right))
    })

    both("-", 3,function(){
        var right = expression(3);
        return NEGONE.times(right == null ? ZERO : right)
    }, function(left){
        var right = expression(3);
        return (left == null ? ZERO : left).minus((right == null ? ZERO : right))
    })

    both("*", 4,function(){
        var right = expression(4);
        return (right == null ? ONE : right)
    }, function(left){
        var right = expression(4);
        return (left == null ? ONE : left).times((right == null ? ONE : right))
    })

    both("/", 4,function(){
        var right = expression(4);
        return ONE.per(right == null ? ONE : right)
    }, function(left){
        var right = expression(4);
        return (left == null ? ONE : left).per((right == null ? ONE : right))
    })

    both("^", 5, function(){
        var right = expression(5);
        return ONE.pow((right == null ? ZERO : right)[0][0])
    }, function(left){
        var right = expression(5);
        return (left == null ? ONE : left).pow((right == null ? ZERO : right)[0][0])
    })


    symbol(")", 0)

    prefix("(", function(){
        var e = expression(0);
        advance(")")
        return e
    })


    infix("=", 2, function(left){
        return variables[left.name] = expression(1)
    })


    statement("variable", function () {
        var a = [], n, t;
        while (true) {
            n = token;
            if (n.arity !== "variable") {
                n.error("Expected a new variable name.");
            }
            advance();
            if (token.id === "=") {
                t = token;
                advance("=");
                t.first = n;
                t.second = expression(0);
                t.arity = "binary";
                a.push(t);
            }
            if (token.id !== ",") {
                break;
            }
            advance(",");
        }
        advance(";");
        return a.length === 0 ? null : a.length === 1 ? a[0] : a;
    })

    both("\n", 0, function(){return null} , function(left){return left})


    if ( module !== undefined && module.exports ) {
        module.exports = parse
    } else {
        root.factory = parse
    }

}(this)
